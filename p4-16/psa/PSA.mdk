Title : P4~16~ Portable Switch Architecture (PSA)
Title Note : (draft)
Title Footer: May 15, 2017
Author : The P4.org language consortium
Heading depth: 4

pre, code {
  language: p4;
}
Colorizer: p4
.token.keyword    {
    font-weight: bold;
    font-family: monospace;
   font-size: 10pt;
}

tbd {
    replace: "~ Begin TbdBlock&nl;\
                   TBD: &source;&nl;\
                   ~ End TbdBlock&nl;";
    color: red;
}

Pdf Latex: pdflatex
Document Class: [10pt]article
Package: [top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
Package: fancyhdr


Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}


[TITLE]
[]{tex-cmd: "\newpage"}
[]{tex-cmd: "\fancyfoot[L]{&date; &time;}"}
[]{tex-cmd: "\fancyfoot[C]{P$4_{16}$ Portable Switch Architecture}"}
[]{tex-cmd: "\fancyfoot[R]{\thepage}"}
[]{tex-cmd: "\pagestyle{fancy}"}

~ Begin Abstract

P4 is a language for expressing how packets are processed by the data
plane of a programmable network forwarding element. P4 programs
specify how the various programmable blocks of a target architecture
are programmed and connected.  The Portable Switch Architecture (PSA)
is target architecture that describes common capabilities of network
switch devices which process and forward packets across multiple
interface ports.

~ End Abstract

# Target Architecture Model


The Portable Switch Architecture (PSA) Model has six programmable P4
blocks and two fixed-function blocks, as shown in Figure
[#fig-switch]. Programmable blocks are hardware blocks whose function
can be programmed using the P4 language. The Packet buffer and
Replication Engine (PRE) and the Buffer Queuing Engine (BQE) are
target dependent functional blocks that may be configured for a fixed
set of operations.

Incoming packets are parsed and have their checksums validated and are
then passed to an ingress match action pipeline, which makes decisions
on where the packets should go. After the ingress pipeline, the packet
may be buffered and/or replicated (sent to multiple egress ports). For
each such egress port, the packet passes through an egress match
action pipeline and a checksum update calculation before it is
deparsed and queued to leave the pipeline..

~ Figure { #fig-switch; caption: "Portable Switch Pipeline"; page-align: here; }
![switch]
~
[switch]: psa_pipeline.png { width: 100%; }

A programmer targeting the PSA is required to instantiate objects for
the programmable blocks that conform to these APIs. Note that the
programmable block APIs are templatized on user defined headers and
metadata. In PSA, the user can define a single metadata type for all
controls.

When instantiating the `main` `package` object, the instances
corresponding to the programmable blocks are passed as arguments.

# PSA Data types

## PSA type definitions

These types need to be defined before including the architecture file
and the macro protecting them should be defined.

```
typedef bit<unspecified> PortId_t;
typedef bit<unspecified> MulticastGroup_t;
typedef bit<unspecified> PacketLength_t;
typedef bit<unspecified> EgressInstance_t;
typedef bit<unspecified> ParserStatus_t;
typedef bit<unspecified> ParserErrorLocation_t;
typedef bit<unspecified> entry_key;           /// for DirectCounters

const   PortId_t         PORT_CPU = unspecified;

```

## PSA supported metadata types

```
enum InstanceType_t { NORMAL_INSTANCE, CLONE_INSTANCE }

struct psa_parser_input_metadata_t {
  PortId_t                 ingress_port;
  InstanceType_t           instance_type;
}

struct psa_ingress_input_metadata_t {
  PortId_t                 ingress_port;
  InstanceType_t           instance_type;  /// Clone or Normal
  /// set by the runtime in the parser, these are not under programmer control
  ParserStatus_t           parser_status;
  ParserErrorLocation_t    parser_error_location;
}

struct psa_ingress_output_metadata_t {
  PortId_t                 egress_port;
}

struct psa_egress_input_metadata_t {
  PortId_t                 egress_port;
  InstanceType_t           instance_type;  /// Clone or Normal
  EgressInstance_t         instance;       /// instance coming from PRE
}
```

## Match kinds

Additional supported match_kind types

```
match_kind {
    range,   /// Used to represent min..max intervals
    selector /// Used for implementing dynamic_action_selection
}
```

## Cloning methods

```
enum CloneMethod_t {
  /// Clone method         Packet source             Insertion point
  Ingress2Ingress,  /// original ingress,            Ingress parser
  Ingress2Egress,    /// post parse original ingress,  Buffering queue
  Egress2Ingress,   /// post deparse in egress,      Ingress parser
  Egress2Egress     /// inout to deparser in egress, Buffering queue
}
```

# PSA Externs

## Packet Replication Engine

The ```PacketReplicationEngine``` extern represents the non-programmable
part of the PSA pipeline.

Even though the PRE can not be programmed using P4, it can be
configured both directly using control plane APIs and by setting
intrinsic metadata. In this specification we opt to define the
operations available in the PRE as method invocations. A target
backend is responsible for mapping the PRE extern APIs to the
appropriate mechanisms for performing these operations in the
hardware.

The PRE is instantiated by the architecture and a P4 program can use
it directly. It is an error to instantiate the PRE multiple times.
The PRE is made available to the Ingress programmable block using the
same mechanism as packet_in. A corresponding Buffering and Queuing
Engine (BQE) extern is defined for the Egress pipeline (@see
BufferingQueueingEngine).

Note: some of these operations may not be implemented as primitive
operations on a certain target. However, All of the operations can be
implemented as a combination of other operations. Applications that
rely on non-primitive operations may incur significant performance
penalties, however, they should be functionally correct.

Semantics of behavior for multiple calls to PRE APIs

The semantics of calling the PRE APIs is equivalent to setting
intrinsic metadata fields/bits and assuming that the PRE looks up the
fields in the following order: drop, truncate, multicast, clone,
output_port.

 Following this semantics, examples of the behaviors are:

- any call to drop in the pipeline will cause the packet, and all
   potential clone copies (see below) to drop.

- any call to truncate, will cause the packet (and its clones
   \todo: check) to be truncated.

- multiple calls to send_to_port -- the last call in the ingress
   pipeline sets the output port.

- multiple calls to multicast -- the last in the ingress pipeline
   sets the multicast group

- interleaving send_to_port and multicast -- the semantics of multicast
   is defined as below (https://github.com/p4lang/tutorials/issues/22):
     if (multicast_group != 0)
        multicast_to_group(multicast_group);
     else
        send_to_port(output_port);

   From this, it follows that if there is a call that sets the
   multicast_group, the packet will be multicast to the group that
   last set the multicast group. Otherwise, the packet will be sent
   to the port set by send_to_port.

- multiple clone invocations will cause the packet to be cloned to
   the corresponding port. Any drop call in the pipeline will cause
   the packet to drop, and no clone will be created (following the
   analogy with intrinsic metadata bit fields, drop bits are
   processed before clone bits are looked up).

- resubmit
- recirculate

\TODO: finalize the semantics of calling multiple of the PRE APIs

```
extern PacketReplicationEngine {

  // PacketReplicationEngine(); /// No constructor. PRE is instantiated
                                /// by the architecture.
```

### PRE Methods

#### Unicast operation

Sends packet to a port.

Targets may implement this operation by setting the appropriate
intrinsic metadata or through some other mechanism of configuring the
PRE.

The port parameter is the output port. If the port is PORT_CPU the
packet will be sent to CPU.

```
void send_to_port (in PortId_t port);
```

#### Multicast operation

Sends packet to a multicast group or a port.

Targets may implement this operation by setting the appropriate
intrinsic metadata or through some other mechanism of configuring the
PRE.

The multicast_group parameter is the multicast group id. The control
plane must program the multicast groups through a separate mechanism.

```
void multicast (in MulticastGroup_t multicast_group);
```

#### Drop operation

Do not forward the packet.

The PSA implements drop as an operation in the PRE. While the drop
operation can be invoked anywhere in the ingress pipeline, the
semantics supported by the PSA is that the drop will be at the end of
the pipeline (ingress or egress).

```
void drop      ();
```

#### Clone operation

Create a copy of the packet and send it to the specified port.

The PSA specifies four types of cloning, with the packet sourced
from different points in the pipeline and sent back to ingress
or to the buffering queue in the egress (@see CloneMethod_t).
\TODO: needs both source and destination data

Parameters:

- clone_method  The type of cloning.
- port          The port to send the cloned packet to.

```
void clone     (in CloneMethod_t clone_method, in PortId_t port);
```

#### Clone with extra data operation { #sec-pre-clone-with-data }

Create a copy of the packet with additional data and send it to the
specified port.

The PSA specifies four types of cloning, with the packet sourced
from different points in the pipeline and sent back to ingress
or to the buffering queue in the egress (@see CloneMethod_t).
\TODO: needs both source and destination data

Parameters:

- clone_method  The type of cloning.
- port          The port to send the cloned packet to.
- data additional header data attached to the packet

```
void clone<T>  (in CloneMethod_t clone_method, in PortId_t port, in T data);
```

#### Resubmit operation

Send a packet to the ingress port with additional data appended.

This operation is intended for recursive packet processing.
\TODO: needs both source and destination data

Parameters:

- data A header definition that can be added to the set of
  packet headers.
- port The input port at which the packet will be resubmitted.

```
void resubmit<T>(in T data, in PortId_t port);
```

#### Recirculate operation

Send a post deparse packet to the ingress port with additional data
appended.

This operation is intended for recursive packet processing.
\TODO: needs both source and destination data

Parameters:

- data A header definition that can be added to the set of packet headers.
- port The input port at which the packet will be resubmitted.

```
void recirculate<T>(in T data, in PortId_t port);
```

#### Truncate operation

Truncate the outgoing packet to the specified length.

The length parameter represents the packet length.

```
void truncate(in bit<32> length);
```

## Buffering Queuing Engine

The BufferingQueueingEngine extern represents the the other
non-programmable part of the PSA pipeline (after Egress).

Even though the BQE can not be programmed using P4, it can be
configured both directly using control plane APIs and by setting
intrinsic metadata. In this specification we opt to define the
operations available in the BQE as method invocations. A target
backend is responsible for mapping the BQE extern APIs to the
appropriate mechanisms for performing these operations in the
hardware.

The BQE is instantiated by the architecture and a P4 program can
use it directly. It is an error to instantiate the BQE multiple
times.  The BQE is made available to the Egress programmable block
using the same mechanism as packet_in. A corresponding Packet
Replication Engine (PRE) extern is defined for the Ingress pipeline
(@see PacketReplicationEngine).

Note: some of these operations may not be implemented as primitive
operations on a certain target. However, All of the operations can
be implemented as a combination of other operations. Applications
that rely on non-primitive operations may incur significant
performance penalties, however, they should be functionally
correct.

The ordering semantics of multiple calls to BQE APIs is identical
to the semantics ordering of PRE invocations, for the subset of
functions supported in the BQE.

```
extern BufferingQueueingEngine {

  // BufferingQueueingEngine(); /// No constructor. BQE is instantiated
                                /// by the architecture.

```

### BQE Methods


#### Unicast operation { #sec-bqe-unicast }

Sends packet to port.

Targets may implement this operation by setting the appropriate
intrinsic metadata or through some other mechanism of configuring the
BQE.

The port parameter is the output port. If the port is PORT_CPU the
packet will be sent to CPU.

```
void send_to_port (in PortId_t port);
```

#### Drop operation { #sec-bqe-drop }

Do not forward the packet.

The PSA implements drop as an operation in the BQE. While the
drop operation can be invoked anywhere in the ingress pipeline,
the semantics supported by the PSA is that the drop will be at
the end of the pipeline (ingress or egress).

```
void drop      ();
```

#### Truncate operation { #sec-bqe-truncate }

Truncate the outgoing packet to the specified length

The length parameter represents the packet length.

```
void truncate(in bit<32> length);
```

## Hashes

Supported hash algorithms:
```
enum HashAlgorithm {
  identity,
  crc32,
  crc32_custom,
  crc16,
  crc16_custom,
  ones_complement16,  /// One's complement 16-bit sum used for IPv4 headers,
                      /// TCP, and UDP.
  random              /// are random hash algorithms useful?
}
```

### Hash function

Example usage:

```
parser P() {
  Hash<bit<16>>(HashAlgorithm.crc16) h;
  bit<16> hash_value = h.getHash(buffer);
}
```

Parameters:

- algo The algorithm to use for computation (@see HashAlgorithm).
- O    The type of the return value of the hash.

```
extern Hash<O> {
  /// Constructor
  Hash(HashAlgorithm algo);

  /// Compute the hash for data.
  /// @param data The data over which to calculate the hash.
  /// @return The hash value.
  O getHash<D>(in D data);

  /// Compute the hash for data, with modulo by max, then add base.
  /// @param base Minimum return value.
  /// @param data The data over which to calculate the hash.
  /// @param max The hash value is divided by max to get modulo.
  ///        An implementation may limit the largest value supported,
  ///        e.g. to a value like 32, or 256.
  /// @return (base + (h % max)) where h is the hash value.
  O getHash<T, D>(in T base, in D data, in T max);
}
```

TBD: Should there be a `const` defined that specifies the maximum
allowed value of `max` parameter?


## Checksum computation

Checksums and hash value generators are examples of functions that
operate on a stream of bytes from a packet to produce an integer. The
integer may be used, for example, as an integrity check for a packet
or as a means to generate a pseudo-random value in a given range on a
packet-by-packet or flow-by-flow basis.

Parameters:

- W    The width of the checksum

```
extern Checksum<W> {
  Checksum(HashAlgorithm hash);          /// constructor
  void clear();              /// prepare unit for computation
  void update<T>(in T data); /// add data to checksum
  void remove<T>(in T data); /// remove data from existing checksum
  W    get();      	     /// get the checksum for data added since last clear
}
```

## Counters

Counters are a mechanism for keeping statistics.  The control plane
can read counter values.  A P4 program cannot read counter values,
only update them.  If you wish to implement a feature involving
sequence numbers, for example, use Registers instead (Section
[#sec-registers]).

Direct counters are counters associated with a particular P4 table,
and are implemented by the extern `DirectCounter`.  There are also
'indirect' counters, which are implemented by the extern `Counter`.
The primary differences between direct counters and indirect counters
are:

- Number of independently updatable counter values:
  - A single instantiation of a direct counter always contains as many
    independent counter values as the number of entries in the table
    with which it is associated.
  - You must specify the number of independent counter values for an
    indirect counter when instantiating it.  This number of counters
    need not be the same as the size of any P4 table.
- Where counter updates are allowed in the P4 program:
  - For a direct counter, you may only invoke its `count` method from
    inside the actions of the table with which it is associated, and
    this always updates the counter value associated with the matching
    table entry.
  - For an indirect counter, you may invoke its `count` method
    anywhere in the P4 program where extern object method invocations
    are permitted (e.g. inside actions, or directly inside a control's
    `apply` block), and every such invocation must specify the index
    of the counter value to be updated.

One may implement packet counters by always using the `count` method
that adds 1 to the counter value.

One may implement byte counters by using the `count` method that adds
a caller-specified `add_value` to the counter, containing a value that
you wish to use for the length of the packet.

We mention these as common use cases for counters.  You may of course
use them to count things other than packets or bytes.


### Counter

```
/// Indirect counter with n_counters independent counter values, where
/// every counter value has a size specified by type W.  Each counter
/// can be updated either by adding 1 via the `count(index)` method,
/// or by adding a value add_value with size specified by type V.
/// Type W must contain at least as many bits as type V.
///
/// Type N is separate from type S to handle the case when the number
/// of counter values is a power of 2, but you wish to use the fewest
/// bits possible in type S for the index.  Type S must contain enough
/// bits to specify all values in the range [0, n_counters - 1].

extern Counter<W, V, S> {
  Counter(bit<32> n_counters);
  void count(in S index, in V add_value);
  void count(in S index);

  /*
  @ControlPlaneAPI
  {
    W    read<W>      (in S index);
    W    read_and_clear<W> (in S index);
    W    sync_read<W> (in S index);
    void set          (in S index, in W seed);
    void reset        (in S index);
    void start        (in S index);
    void stop         (in S index);
  }
  */
}
```

See below for pseudocode of a reference implementation for the Counter
extern.

```
Counter(N n_counters) {
    this.num_counters = n_counters;
    this.counter_vals = new array of size n_counters, each element with type W;
    this.max_counter_value = maximum value possible for type W;
}

/// Add @add_value to a saturating counter whose current value is
/// @cur_value, and whose maximum possible value is @max_value.
///
/// Assume that type W is bit<X> and type V is bit<Y> where X >= Y.
/// There is very little, if any, reason to use signed count values.

W next_counter_value(W cur_value, V add_value, W max_value) {
    bit<X+1> next_value = (bit<X+1>) cur_value + (bit<X+1>) add_value;
    if (next_value[X] == 1) {
        return max_value;
    }
    return (bit<X>) next_value;
}

void count(in S index, in V add_value) {
    if (index < this.num_counters) {
        this.counter_vals[index] = next_counter_value(this.counter_vals[index],
                                           add_value, this.max_counter_value);
    } else {
        // No counter_vals updated if index is out of range.
        // See below for optional debug information to record.
    }
}

void count(in S index) {
    count(index, 1);
}
```

Rationale for saturating behavior: With saturating behavior, the
control plane can know that information was lost, if it reads the
maximum possible value from a counter.  In this case, it knows that
the true count value is at least the maximum value.  With wrap-around
behavior, the control plane has no way to know if wrapping occurred.

Optional debugging information that may be kept if an `index` value is
out of range includes:

- Number of times this occurs.
- A FIFO of the first N out-of-range index valus that occur, where N
  is implementation-defined (e.g. it might only be 1).  Extra
  information to identify which `count()` method call in the P4
  program had the out-of-range `index` value is also recommended.


### Direct Counter

```
extern DirectCounter<W, V> {
  DirectCounter();
  void count(in V add_value);
  void count();

  /*
  @ControlPlaneAPI
  {
    W    read<W>      (in entry_key key);
    W    sync_read<W> (in entry_key key);
    void set          (in W seed);
    void reset        (in entry_key key);
    void start        (in entry_key key);
    void stop         (in entry_key key);
  }
  */
}
```

A `DirectCounter` instance must appear in the list of values of the
`psa_direct_counters` table attribute for exactly one table.  We call
this table the `DirectCounter` instance's "owner".  It is illegal to
call the `count` method for a `DirectCounter` instance anywhere except
inside an action of its owner table.

The counter value updated by an invocation of `count` is always the
one associated with the table entry that matched.

An action of an owner table need not have `count` method calls for all
of the `DirectCounter` instances that the table owns.

The reference implementation for the `DirectCounter` extern is
essentially the same as that for `Counter`, including the saturating
behavior.  Since there is no `index` parameter to the `count` method,
there is no need to check for whether it is in range.

TBD: What to say about `entry_key` type?  Does it need to be made more
precise?

TBD: The rules above seem to imply that an action that calls `count`
on a `DirectCounter` instance may only be an action of that instance's
one owner table.  Normally an action definition can be shared across
multiple tables (e.g. NoAction, but also the definition of more
complex actions can be shared across tables, even ones inside of
different control blocks if the action is defined at the top level).
This seems to be a restriction for actions accessing 'direct' kinds of
resources, unless there is a way to define an action that somehow
takes as a parameter a reference to a `DirectCounter` instance to
update.

TBD: Should a `DirectCounter` instance have a counter value associated
with a miss search result for its owner table?  This is perhaps
superfluous for tables with `ternary` and `lpm` match kinds, since the
control plane can always insert a lowest priority entry that matches
all search keys that will have its own explicit counter value
associated with it.  It might be useful for tables with the `exact`
match kind.


### Counter examples

The following partial P4 program demonstrates the instantiation and
updating of `Counter` and `DirectCounter` externs, including
implementing both a packet and byte `DirectCounter` instance for table
`ipv4_da_lpm`.

```
const bit<32> BYTE_COUNTER_WIDTH = 48;
typedef bit<48> ByteCounter_t;
const bit<32> PACKET_COUNTER_WIDTH = 32;
typedef bit<32> PacketCounter_t;

typedef bit<10> PortId_t;
const PortId_t MAX_PORTS = 512;

typedef bit<14> PacketLength_t;

struct headers {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
}

control ingress(inout headers hdr,
                inout meta user_meta,
                PacketReplicationEngine pre,
                in  psa_ingress_input_metadata_t  istd,
                out psa_ingress_output_metadata_t ostd)
{
    Counter<ByteCounter_t, PacketLength_t, PortId_t>((bit<32>) MAX_PORTS)
        port_bytes_in;
    DirectCounter<PacketCounter_t, bit<1>>() per_prefix_pkt_count;
    DirectCounter<ByteCounter_t, PacketLength_t>() per_prefix_byte_count;

    action next_hop() {
        per_prefix_pkt_count.count();
        per_prefix_byte_count.count((PacketLength_t) hdr.ipv4.totalLen);
        // other action code here
    }
    action default_route_drop() {
        per_prefix_pkt_count.count();
        per_prefix_byte_count.count((PacketLength_t) hdr.ipv4.totalLen);
        // other action code here
    }
    table ipv4_da_lpm {
        key = { hdr.ipv4.dstAddress: lpm; }
        actions = {
            next_hop;
            default_route_drop;
        }
        default_action = default_route_drop;
        psa_direct_counters = {
            // table ipv4_da_lpm owns both of these DirectCounter instances
            per_prefix_pkt_count;
            per_prefix_byte_count;
        }
    }

    apply {
        // In this program, we want to count IP layer bytes received
        // and transmitted on interfaces, not L2.
        if (hdr.ipv4.isValid()) {
            port_bytes_in.count(istd.ingress_port,
                                (PacketLength_t) hdr.ipv4.totalLen);
            ipv4_da_lpm.apply();
        }
    }
}

control egress(inout headers hdr
               // ...
               )
{
    Counter<ByteCounter_t, PacketLength_t, PortId_t>((bit<32>) MAX_PORTS)
        port_bytes_out;
    apply {
        // Note that hdr.ipv4.totalLen for a packet may have been
        // changed since the packet was received on ingress,
        // e.g. because of IP tunnel encapsulation or termination.

        // Also by doing these stats updates on egress, as long as IP
        // multicast replication happens in the packet buffer, this
        // update will occur once for each copy made, which in this
        // example is intentional.
        if (hdr.ipv4.isValid()) {
            port_bytes_out.count(ostd.egress_port,
                                 (PacketLength_t) hdr.ipv4.totalLen);
        }
    }
}
```

## Meters

Meters (RFC 2698) are a more complex mechanism for keeping statistics about
the packets that trigger a table. The meters specified in the PSA
are 3-color meters.


### Meter types
```
enum MeterType_t {
    packets,
    bytes
}
```

### Meter colors

```
enum MeterColor_t { RED, GREEN, YELLOW };
```

### Meter

```
extern Meter<S> {
  Meter(S n_meters, MeterType_t type);
  MeterColor_t execute(in S index, in MeterColor_t color);

  /*
  @ControlPlaneAPI
  {
    reset(in MeterColor_t color);
    setParams(in S committedRate, in S committedBurstSize
              in S peakRate, in S peakBurstSize);
    getParams(out S committedRate, out S committedBurstSize
              out S peakRate, out S peakBurstSize);
  }
  */
}
```

### Direct Meter

```
extern DirectMeter {
  DirectMeter(MeterType_t type);
  MeterColor_t execute(in MeterColor_t color);

  /*
  @ControlPlaneAPI
  {
    reset(in entry_key entry, in MeterColor_t color);
    void setParams<S>(in entry_key entry,
                      in S committedRate, in S committedBurstSize
                      in S peakRate, in S peakBurstSize);
    void getParams<S>(in entry_key entry,
                      out S committedRate, out S committedBurstSize
                      out S peakRate, out S peakBurstSize);
  }
  */
}
```

## Registers { #sec-registers }

Registers are stateful memories whose values can be read and
written in actions. Registers are similar to counters, but can be
used in a more general way to keep state.

Although registers cannot be used directly in matching,
register.read may be used as the RHS of an assignment operation,
allowing the current value of the register to be copied into
metadata and be available for matching in subsequent tables.

A simple usage example might be to verify that a "first packet" was seen
for a particular type of flow. A register cell would be allocated to
the flow, initialized to "clear". When the protocol signaled a "first
packet", the table would match on this value and update the flowâ€™s
cell to "marked". Subsequent packets in the flow could would be mapped
to the same cell; the current cell value would be stored in metadata
for the packet and a subsequent table could check that the flow was
marked as active.


```
extern Register<T, S> {
  Register(S size);
  T    read  (in S index);
  void write (in S index, in T value);

  /*
  @ControlPlaneAPI
  {
    T    read<T>      (in S index);
    void set          (in S index, in T seed);
    void reset        (in S index);
  }
  */
}
```

## Random

The random extern provides a reliable, target specific number generator
in the min .. max range.


The set of distributions supported by the Random extern.
\TODO: should this be removed in favor of letting the extern
return whatever distribution is supported by the target?

```
enum RandomDistribution {
  PRNG,
  Binomial,
  Poisson
}
```

```
extern Random<T> {
  Random(RandomDistribution dist, T min, T max);
  T read();

  /*
  @ControlPlaneAPI
  {
    void reset();
    void setSeed(in T seed);
  }
  */
}
```

## Action Profile

Action profiles are used as table implementation attributes.

Action profiles implement a mechanism to populate table entries
with actions and action data. The only data plane operation
required is to instantiate this extern. When the control plane adds
entries (members) into the extern, they are essentially populating
the corresponding table entries.

```
extern ActionProfile {
  /// Construct an action profile of 'size' entries
  ActionProfile(bit<32> size);

  /*
  @ControlPlaneAPI
  {
     entry_handle add_member    (action_ref, action_data);
     void         delete_member (entry_handle);
     entry_handle modify_member (entry_handle, action_ref, action_data);
  }
  */
}
```

## Action Selector

Action selectors are used as table implementation attributes.

Action selectors implement another mechanism to populate table
entries with actions and action data. They are similar to action
profiles, with additional support to define groups of
entries. Action selectors require a hash algorithm to select
members in a group. The only data plane operation required is to
instantiate this extern. When the control plane adds entries
(members) into the extern, they are essentially populating the
corresponding table entries.

```
extern ActionSelector {
  /// Construct an action selector of 'size' entries
  /// @param algo hash algorithm to select a member in a group
  /// @param size number of entries in the action selector
  /// @param outputWidth size of the key
  ActionSelector(HashAlgorithm algo, bit<32> size, bit<32> outputWidth);

  /*
  @ControlPlaneAPI
  {
     entry_handle add_member        (action_ref, action_data);
     void         delete_member     (entry_handle);
     entry_handle modify_member     (entry_handle, action_ref, action_data);
     group_handle create_group      ();
     void         delete_group      (group_handle);
     void         add_to_group      (group_handle, entry_handle);
     void         delete_from_group (group_handle, entry_handle);
  }
  */
}
```

## Packet Generation

\TODO: is generating a new packet and sending it to the stream or is
it adding a header to the current packet and sending it to the
stream (copying or redirecting).

```
extern Digest<T> {
  Digest(PortId_t receiver); /// define a digest stream to receiver
  void emit(in T data);      /// emit data into the stream

  /*
  @ControlPlaneAPI
  {
  // TBD
  // If the type T is a named struct, the name should be used
  // to generate the control-plane API.
  }
  */
}
```

# Programmable blocks

The following declarations provide a template for the programmable
blocks in the PSA. The P4 programmer is responsible for
implementing controls that match these interfaces and instantiate
them in a package definition.

The current implementation uses the same user-defined metadata
structure for all the controls.
An alternative design is to split the user-defined metadata into an
input parameter and an output parameter for each block. The
compiler will have to check that the out parameter of a block
matches the in parameter of the subsequent block.


```
parser Parser<H, M>(packet_in buffer, out H parsed_hdr, inout M user_meta,
                    in psa_parser_input_metadata_t istd);

control VerifyChecksum<H, M>(in H hdr, inout M user_meta);

control Ingress<H, M>(inout H hdr, inout M user_meta,
                      PacketReplicationEngine pre,
                      in  psa_ingress_input_metadata_t  istd,
                      out psa_ingress_output_metadata_t ostd);

control Egress<H, M>(inout H hdr, inout M user_meta,
                     BufferingQueueingEngine bqe,
                     in  psa_egress_input_metadata_t  istd);

control ComputeChecksum<H, M>(inout H hdr, inout M user_meta);

control Deparser<H>(packet_out buffer, in H hdr);

package PSA_Switch<H, M>(Parser<H, M> p,
                         VerifyChecksum<H, M> vr,
                         Ingress<H, M> ig,
                         Egress<H, M> eg,
                         ComputeChecksum<H, M> ck,
                         Deparser<H> dep);
```
