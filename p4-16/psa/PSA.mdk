Title : P4~16~ Portable Switch Architecture (PSA)
Title Note : (draft)
Title Footer: May 15, 2017
Author : The P4.org language consortium
Heading depth: 4

pre, code {
  language: p4;
}
Colorizer: p4
.token.keyword    {
    font-weight: bold;
    font-family: monospace;
   font-size: 10pt;
}

tbd {
    replace: "~ Begin TbdBlock&nl;\
                   TBD: &source;&nl;\
                   ~ End TbdBlock&nl;";
    color: red;
}

Pdf Latex: pdflatex
Document Class: [10pt]article
Package: [top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
Package: fancyhdr


Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}


[TITLE]
[]{tex-cmd: "\newpage"}
[]{tex-cmd: "\fancyfoot[L]{&date; &time;}"}
[]{tex-cmd: "\fancyfoot[C]{P$4_{16}$ Portable Switch Architecture}"}
[]{tex-cmd: "\fancyfoot[R]{\thepage}"}
[]{tex-cmd: "\pagestyle{fancy}"}

~ Begin Abstract

P4 is a language for expressing how packets are processed by the data
plane of a programmable network forwarding element. P4 programs
specify how the various programmable blocks of a target architecture
are programmed and connected.  The Portable Switch Architecture (PSA)
is target architecture that describes common capabilities of network
switch devices which process and forward packets across multiple
interface ports.

~ End Abstract

# Target Architecture Model


The Portable Switch Architecture (PSA) Model has six programmable P4
blocks and two fixed-function blocks, as shown in Figure
[#fig-switch]. Programmable blocks are hardware blocks whose function
can be programmed using the P4 language. The Packet buffer and
Replication Engine (PRE) and the Buffer Queuing Engine (BQE) are
target dependent functional blocks that may be configured for a fixed
set of operations.

Incoming packets are parsed and have their checksums validated and are
then passed to an ingress match action pipeline, which makes decisions
on where the packets should go. After the ingress pipeline, the packet
may be buffered and/or replicated (sent to multiple egress ports). For
each such egress port, the packet passes through an egress match
action pipeline and a checksum update calculation before it is
deparsed and queued to leave the pipeline..

~ Figure { #fig-switch; caption: "Portable Switch Pipeline"; page-align: here; }
![switch]
~
[switch]: psa_pipeline.png { width: 100%; }

A programmer targeting the PSA is required to instantiate objects for
the programmable blocks that conform to these APIs. Note that the
programmable block APIs are templatized on user defined headers and
metadata. In PSA, the user can define a single metadata type for all
controls.

When instantiating the `main` `package` object, the instances
corresponding to the programmable blocks are passed as arguments.

# PSA Data types

## PSA type definitions

These types need to be defined before including the architecture file
and the macro protecting them should be defined.

```
[INCLUDE=psa.p4:Type_defns]
```

## PSA supported metadata types

```
[INCLUDE=psa.p4:Metadata_types]
```

## Match kinds

Additional supported match_kind types

```
[INCLUDE=psa.p4:Match_kinds]
```

## Cloning methods { #sec-cloning-methods }

```
[INCLUDE=psa.p4:Cloning_methods]
```

# PSA Externs

## Packet Replication Engine { #sec-pre }

The ```PacketReplicationEngine``` extern represents the non-programmable
part of the PSA pipeline.

Even though the PRE can not be programmed using P4, it can be
configured both directly using control plane APIs and by setting
intrinsic metadata. In this specification we opt to define the
operations available in the PRE as method invocations. A target
backend is responsible for mapping the PRE extern APIs to the
appropriate mechanisms for performing these operations in the
hardware.

The PRE is instantiated by the architecture and a P4 program can use
it directly. It is an error to instantiate the PRE multiple times.
The PRE is made available to the Ingress programmable block using the
same mechanism as packet_in. A corresponding Buffering and Queuing
Engine (BQE) extern is defined for the Egress pipeline (see
[#sec-bqe]).

Note: some of these operations may not be implemented as primitive
operations on a certain target. However, All of the operations can be
implemented as a combination of other operations. Applications that
rely on non-primitive operations may incur significant performance
penalties, however, they should be functionally correct.

Semantics of behavior for multiple calls to PRE APIs

The semantics of calling the PRE APIs is equivalent to setting
intrinsic metadata fields/bits and assuming that the PRE looks up the
fields in the following order: drop, truncate, multicast, clone,
output_port.

 Following this semantics, examples of the behaviors are:

- any call to drop in the pipeline will cause the packet, and all
   potential clone copies (see below) to drop.

- any call to truncate, will cause the packet (and its clones
   \todo: check) to be truncated.

- multiple calls to send_to_port -- the last call in the ingress
   pipeline sets the output port.

- multiple calls to multicast -- the last in the ingress pipeline
   sets the multicast group

- interleaving send_to_port and multicast -- the semantics of multicast
   is defined as below (https://github.com/p4lang/tutorials/issues/22):
     if (multicast_group != 0)
        multicast_to_group(multicast_group);
     else
        send_to_port(output_port);

   From this, it follows that if there is a call that sets the
   multicast_group, the packet will be multicast to the group that
   last set the multicast group. Otherwise, the packet will be sent
   to the port set by send_to_port.

- multiple clone invocations will cause the packet to be cloned to
   the corresponding port. Any drop call in the pipeline will cause
   the packet to drop, and no clone will be created (following the
   analogy with intrinsic metadata bit fields, drop bits are
   processed before clone bits are looked up).

- resubmit
- recirculate

\TODO: finalize the semantics of calling multiple of the PRE APIs

```
extern PacketReplicationEngine {

  // PacketReplicationEngine(); /// No constructor. PRE is instantiated
                                /// by the architecture.
```

### PRE Methods

#### Unicast operation

Sends packet to a port.

Targets may implement this operation by setting the appropriate
intrinsic metadata or through some other mechanism of configuring the
PRE.

The port parameter is the output port. If the port is PORT_CPU the
packet will be sent to CPU.

```
void send_to_port (in PortId_t port);
```

#### Multicast operation

Sends packet to a multicast group or a port.

Targets may implement this operation by setting the appropriate
intrinsic metadata or through some other mechanism of configuring the
PRE.

The multicast_group parameter is the multicast group id. The control
plane must program the multicast groups through a separate mechanism.

```
void multicast (in MulticastGroup_t multicast_group);
```

#### Drop operation

Do not forward the packet.

The PSA implements drop as an operation in the PRE. While the drop
operation can be invoked anywhere in the ingress pipeline, the
semantics supported by the PSA is that the drop will be at the end of
the pipeline (ingress or egress).

```
void drop      ();
```

#### Clone operation

Create a copy of the packet and send it to the specified port.

The PSA specifies four types of cloning, with the packet sourced
from different points in the pipeline and sent back to ingress
or to the buffering queue in the egress (see [#sec-cloning-methods]).
\TODO: needs both source and destination data

Parameters:

- clone_method  The type of cloning.
- port          The port to send the cloned packet to.

```
void clone     (in CloneMethod_t clone_method, in PortId_t port);
```

#### Clone with extra data operation { #sec-pre-clone-with-data }

Create a copy of the packet with additional data and send it to the
specified port.

The PSA specifies four types of cloning, with the packet sourced
from different points in the pipeline and sent back to ingress
or to the buffering queue in the egress (see [#sec-cloning-methods]).
\TODO: needs both source and destination data

Parameters:

- clone_method  The type of cloning.
- port          The port to send the cloned packet to.
- data additional header data attached to the packet

```
void clone<T>  (in CloneMethod_t clone_method, in PortId_t port, in T data);
```

#### Resubmit operation

Send a packet to the ingress port with additional data appended.

This operation is intended for recursive packet processing.
\TODO: needs both source and destination data

Parameters:

- data A header definition that can be added to the set of
  packet headers.
- port The input port at which the packet will be resubmitted.

```
void resubmit<T>(in T data, in PortId_t port);
```

#### Recirculate operation

Send a post deparse packet to the ingress port with additional data
appended.

This operation is intended for recursive packet processing.
\TODO: needs both source and destination data

Parameters:

- data A header definition that can be added to the set of packet headers.
- port The input port at which the packet will be resubmitted.

```
void recirculate<T>(in T data, in PortId_t port);
```

#### Truncate operation

Truncate the outgoing packet to the specified length.

The length parameter represents the packet length.

```
void truncate(in bit<32> length);
```

## Buffering Queuing Engine { #sec-bqe }

The BufferingQueueingEngine extern represents the the other
non-programmable part of the PSA pipeline (after Egress).

Even though the BQE can not be programmed using P4, it can be
configured both directly using control plane APIs and by setting
intrinsic metadata. In this specification we opt to define the
operations available in the BQE as method invocations. A target
backend is responsible for mapping the BQE extern APIs to the
appropriate mechanisms for performing these operations in the
hardware.

The BQE is instantiated by the architecture and a P4 program can
use it directly. It is an error to instantiate the BQE multiple
times.  The BQE is made available to the Egress programmable block
using the same mechanism as packet_in. A corresponding Packet
Replication Engine (PRE) extern is defined for the Ingress pipeline
(see [#sec-pre]).

Note: some of these operations may not be implemented as primitive
operations on a certain target. However, All of the operations can
be implemented as a combination of other operations. Applications
that rely on non-primitive operations may incur significant
performance penalties, however, they should be functionally
correct.

The ordering semantics of multiple calls to BQE APIs is identical
to the semantics ordering of PRE invocations, for the subset of
functions supported in the BQE.

```
extern BufferingQueueingEngine {

  // BufferingQueueingEngine(); /// No constructor. BQE is instantiated
                                /// by the architecture.

```

### BQE Methods


#### Unicast operation { #sec-bqe-unicast }

Sends packet to port.

Targets may implement this operation by setting the appropriate
intrinsic metadata or through some other mechanism of configuring the
BQE.

The port parameter is the output port. If the port is PORT_CPU the
packet will be sent to CPU.

```
void send_to_port (in PortId_t port);
```

#### Drop operation { #sec-bqe-drop }

Do not forward the packet.

The PSA implements drop as an operation in the BQE. While the
drop operation can be invoked anywhere in the ingress pipeline,
the semantics supported by the PSA is that the drop will be at
the end of the pipeline (ingress or egress).

```
void drop      ();
```

#### Truncate operation { #sec-bqe-truncate }

Truncate the outgoing packet to the specified length

The length parameter represents the packet length.

```
void truncate(in bit<32> length);
```

## Hashes { #sec-hash-algorithms }

Supported hash algorithms:
```
[INCLUDE=psa.p4:Hash_algorithms]
```

### Hash function

Example usage:

```
parser P() {
  Hash<bit<16>>(HashAlgorithm.crc16) h;
  bit<16> hash_value = h.getHash(buffer);
}
```

Parameters:

- algo The algorithm to use for computation (see [#sec-hash-algorithms]).
- O    The type of the return value of the hash.

```
[INCLUDE=psa.p4:Hash_extern]
```

TBD: Should there be a `const` defined that specifies the maximum
allowed value of `max` parameter?


## Checksum computation

Checksums and hash value generators are examples of functions that
operate on a stream of bytes from a packet to produce an integer. The
integer may be used, for example, as an integrity check for a packet
or as a means to generate a pseudo-random value in a given range on a
packet-by-packet or flow-by-flow basis.

Parameters:

- W    The width of the checksum

```
[INCLUDE=psa.p4:Checksum_extern]
```

## Counters

Counters are a simple mechanism for keeping statistics about the
packets that trigger a table in a Match Action unit.

Direct counters fire when the count method is invoked in an action, and
have an instance for each entry in the table.


### Counter types

```
[INCLUDE=psa.p4:CounterType_defn]
```

### Counter

```
[INCLUDE=psa.p4:Counter_extern]
```

### Direct Counter

```
[INCLUDE=psa.p4:DirectCounter_extern]
```

## Meters

Meters (RFC 2698) are a more complex mechanism for keeping statistics about
the packets that trigger a table. The meters specified in the PSA
are 3-color meters.


### Meter types

```
[INCLUDE=psa.p4:MeterType_defn]
```

### Meter colors

```
[INCLUDE=psa.p4:MeterColor_defn]
```

### Meter

```
[INCLUDE=psa.p4:Meter_extern]
```

### Direct Meter

```
[INCLUDE=psa.p4:DirectMeter_extern]
```

## Registers

Registers are stateful memories whose values can be read and
written in actions. Registers are similar to counters, but can be
used in a more general way to keep state.

Although registers cannot be used directly in matching,
register.read may be used as the RHS of an assignment operation,
allowing the current value of the register to be copied into
metadata and be available for matching in subsequent tables.

A simple usage example might be to verify that a "first packet" was seen
for a particular type of flow. A register cell would be allocated to
the flow, initialized to "clear". When the protocol signaled a "first
packet", the table would match on this value and update the flowâ€™s
cell to "marked". Subsequent packets in the flow could would be mapped
to the same cell; the current cell value would be stored in metadata
for the packet and a subsequent table could check that the flow was
marked as active.


```
[INCLUDE=psa.p4:Register_extern]
```

## Random

The random extern provides a reliable, target specific number generator
in the min .. max range.


The set of distributions supported by the Random extern.
\TODO: should this be removed in favor of letting the extern
return whatever distribution is supported by the target?

```
[INCLUDE=psa.p4:RandomDistribution_defn]
```

```
[INCLUDE=psa.p4:Random_extern]
```

## Action Profile

Action profiles are used as table implementation attributes.

Action profiles implement a mechanism to populate table entries
with actions and action data. The only data plane operation
required is to instantiate this extern. When the control plane adds
entries (members) into the extern, they are essentially populating
the corresponding table entries.

```
[INCLUDE=psa.p4:ActionProfile_extern]
```

## Action Selector

Action selectors are used as table implementation attributes.

Action selectors implement another mechanism to populate table
entries with actions and action data. They are similar to action
profiles, with additional support to define groups of
entries. Action selectors require a hash algorithm to select
members in a group. The only data plane operation required is to
instantiate this extern. When the control plane adds entries
(members) into the extern, they are essentially populating the
corresponding table entries.

```
[INCLUDE=psa.p4:ActionSelector_extern]
```

## Packet Generation

\TODO: is generating a new packet and sending it to the stream or is
it adding a header to the current packet and sending it to the
stream (copying or redirecting).

```
[INCLUDE=psa.p4:Digest_extern]
```

# Programmable blocks

The following declarations provide a template for the programmable
blocks in the PSA. The P4 programmer is responsible for
implementing controls that match these interfaces and instantiate
them in a package definition.

The current implementation uses the same user-defined metadata
structure for all the controls.
An alternative design is to split the user-defined metadata into an
input parameter and an output parameter for each block. The
compiler will have to check that the out parameter of a block
matches the in parameter of the subsequent block.


```
[INCLUDE=psa.p4:Programmable_blocks]
```


# PSA Portability Requirements

This section lists minimum requirements for a P4 implementation to
be PSA compliant.

A PSA compliant implementation is allowed to support P4 programs that
exceed one or more of these limits.  It is also allowed to reject such
a P4 program as 'too complex'.

A PSA compliant implementation must not reject a P4 program that obeys
all of these limitations.  Thus P4 programs that obey all of these
limitations should be portable across all PSA compliant
implementations.

Minimum requirements for packet parsing:

- 32 bits in a parser `select` expression.
- 50 parser states.
- 20 parser state transitions per packet.
- 128 bytes extracted per packet.
- 16 bytes of metadata assigned in the parser.
- 4 ValueSet `is_member` method calls per packet.

Minimum requirements for tables:

- 20 tables applied per packet in ingress.
- 10 tables applied per packet in egress.
- 640 bits of search key for a table with match_kind `ternary`.
- 640 bits of search key for a table with match_kind `lpm`.
- 640 bits of search key for a table with match_kind `exact`.
- 32 different user-defined actions for one table.
- 256 total bits of action parameters for an action.
- 1M entries in a table (1M=2^20^).
- 64 Mbits of table size in bits, which is the number of entries times
  the size of one entry in bits.  The size of one entry is the key
  width, plus the maximum total bits of action parameters, maximized
  across all actions of the table.

Minimum requirements for assignments, and arithmetic and Boolean
operations.  These are total across those done within table actions,
and those done outside of table actions (i.e. directly inside of
control blocks, or within actions that are invoked directly from
control blocks without applying a table).

- 100 assignments executed per packet on ingress.  The same limit
  applies independently for egress.
- 50 arithmetic/Boolean operations on operands up to 32 bits in width,
  per packet, on ingress.  The same limit applies independently for
  egress.
- 5 arithmetic/Boolean operations on operands up to 128 bits in width,
  per packet, on ingress.  The same limit applies independently for
  egress.

Minimum requirements for PSA externs:

- 4 `PacketReplicationEngine` method calls per packet (TBD if there
  should be separate limits for each method call).
- At least 64 bytes of user-defined metadata per packet can be carried
  from the `Ingress` to `Egress` control block through the packet
  buffer.
- 512 copies that can be made of a packet by a
  `PacketReplicationEngine` multicast group.
- 256 multicast groups.
- 4 `BufferingQueueingEngine` method calls per packet (TBD if there
  should be separate limits for each method call).
- 4 `Hash` `getHash` method calls per packet, with 160 total bytes of
  input data.
- 4 `Checksum` `clear` and `get` method calls per packet, with 160
  total bytes of input data as arguments to `update` and `remove`
  method calls.
- 6 counter updates per packet (on different counters, which can be
  any mix of `Counter` or `DirectCounter`).
- 2 meter updates per packet (on different meters, which can be any
  mix of `Meter` or `DirectMeter`).
- 2 `Register` updates per packet (on different registers).  A
  register `read`, followed by register `write`, counts as 1 update.
- 2 `Random` `read` calls per packet.
- TBD `ActionProfile` restrictions.
- TBD `ActionSelector` restrictions.
- TBD digest creations per packet.

A PSA compliant implementation need not, but is allowed to, reject a
P4 program if it does any of the following:

- Applies the same table more than 1 time per packet.
- Calls `getHash` on the same `Hash` instance more than 1 time per
  packet.  (TBD: Is this a useful restriction?)
- Calls `clear` or `get` on the same `Checksum` instance more than 1
  time per packet, or calls `update` and `remove` more than a total of
  6 times per packet.  (TBD: Is this a useful restriction?)
- Updates the same `Counter`, `DirectCounter`, `Meter`, `DirectMeter`,
  or `Register` instance more than 1 time per packet.
- Uses the same `ActionProfile` for more than 1 table.
- Uses the same `ActionSelector` for more than 1 table.
- Calls `emit` on a `Digest` instance more than 1 time per packet.


## Definition of "once per packet"

An operation that is done at most once per packet must fall into one
of the following cases.

1. The operation is done at most once anywhere in the P4 program.
2. For an operation done inside a table action, the operation is done
   at most once in each action for one table, and it is not done
   anywhere else in the program.
3. The operation is done at most once in the "true" branch of an `if`
   statement, and at most once in the "false"/`else` branch of the
   same `if` statement.
4. The operation is done at most once in every case of the same
   `switch` statement.

If an operation is done in the `Egress` control block, such an
operation could be done once for each copy of a packet for which
multiple copies were made via `PacketReplicationEngine` multicast
replication.  This is still considered "once per packet" for the
purposes of this definition.  Think of each packet copy as its own
separate packet, as far as `Egress` processing is concerned.

Similarly, for recirculated or resubmitted packets, consider each such
recirculated/resubmitted packet as a separate one, and such operations
can be done once for the original packet, and for each
recirculated/resubmitted packet.

Cases 2 through 4 are those where it is straightforward for a P4
compiler to determine that the operation occurs at most once per
packet.  These cases can "nest", so for example a PSA compliant
implementation must consider the program fragment below to execute the
operation `c1.count()` at most once per packet (assuming `c1.count()`
is called nowhere else in the program):

```
    if (hdr.ipv4.isValid()) {
        c1.count();
    } else if (hdr.ipv6.isValid()) {
        if (pkt_is_multicast == 1) {
            c1.count();
        } else if (pkt_is_unicast == 1) {
            c1.count();
        } else {
            c1.count();
        }
    }
```

TBD: Do we really want to require PSA compliant implementations to
handle cases 3 and 4, or are 1 and 2 enough?  For example, the example
might be difficult to do for some implementations, if there are match
data dependencies between all of the tables involved:

```
    if (hdr.ipv4.isValid()) {
        T1.apply();
        T2.apply();
        T3.apply();
        T4.apply();
        T5.apply();
    } else {
        T5.apply();
        T4.apply();
        T3.apply();
        T2.apply();
        T1.apply();
    }
```

A PSA compliant implementation is allowed to do more complex "once per
packet" analysis than this, but a program that relies on this is not
guaranteed to be portable across PSA compliant implementations.

For example, while it is possible for a human, or a sufficiently
sophisticated compiler, to determine that the operation `c1.count()`
in the example code fragment below can only be invoked once per
packet, a PSA compliant implementation need not do so.  It is free to
reject the program for performing `c1.count()` more than once per
packet.

```
    if (hdr.ipv4.isValid()) {
        c1.count();
    } else if (hdr.ipv6.isValid()) {
        // ... more code here ...
    }

    // More code here, that cannot change the value of
    // hdr.ipv4.isValid().

    if (hdr.ipv4.isValid()) {
        // ... more code here ...
    } else if (hdr.ipv6.isValid()) {
        c1.count();
    }

```

TBD: We may need some clear but preferably precise way to explain that
when we say "at most once anywhere in the P4 program", if a control
block `C` is applied 2 times sequentially from the `Ingress` control
block, and some operation is done exactly once inside of `C`'s `apply`
block, that counts as 2 times per packet, even though the operation
only occurs once in the source code for control block `C`.  Some
semi-precise definition of "after in-line expansion of all control
block apply calls, and all action calls nested inside of other action
calls" might do it.


## Atomicity of control plane API operations

All table add, delete, and modify operations must be atomic relative
to packet forwarding.  That is, for every table `apply` operation, and
every _single_ control plane API operation on a table, the `apply`
operation should behave as if that single control plane API operation
has not yet occurred at all, or as if the single control plane API
operation is complete.  The P4 program should never behave as if the
control plane API operation is partially complete.

For example, suppose a table `T` has an action `A` with 256 total bits
of action parameters, and the control plane has added a table entry
with a search key `K` and action `A`.  Later the control plane
performs an update operation on the entry with key `K` that leaves the
key `K` the same, but changes the 256 bits of action parameters.
Every packet doing an `apply` on table `T` and matching the entry with
key `K` should execute action `A` with either the old 256 bits of
action parameters, or the new 256 bits of action parameters.

There is no requirement that a sequence of _multiple_ table entry add,
delete, or update operations should be atomic relative to packets
being processed.  There are common "write tables from latest to
earlier in the data flow" techniques used by existing control planes
to achieve this, and control planes must either use techniques like
this, or it is possible for some packets to be processed with the
intermediate state that exists after each individual table operation
is complete.

The same applies for all control plane API operations on externs,
unless the control plane operation explicitly documents otherwise.


## Restrictions on use of stateful types

The tables below summarize restrictions that a PSA portable program
must obey to maximize portability.  PSA compliant implementations are
allowed to reject programs that attempt to do anything not allowed
here.

Some of these are limitations of the P4_16 language itself, but some
are unique to the PSA architecture.

The stateful types of objects in P4_16 are packages, parsers,
controls, externs, and tables.  All other types are referred to as
"value types" here.

Some guiding principles:

- Packages can be instantiated, but have no run-time behavior, so
  there is no use in passing them to anything else other than another
  package.
- Controls are not allowed to call parsers in a PSA portable program,
  and vice versa, so there is no use in passing one type to the other
  in constructor parameters or run-time parameters.
- Externs are not allowed to call parsers or controls (at least in
  PSA, and probably also P4_16 as well), so there is no use in passing
  objects of those types to them.
- Tables are always instantiated directly in their enclosing control,
  and cannot be instantiated at the top level.  There is no type by
  which a table can be passed as either a constructor or run-time
  parameter anywhere else.  They are only intended to be used from
  within the control where they are defined.

The first table lists restrictions on what types can be passed as
constructor parameters to other types.

|-------------|-------------------------------------------------|
|             | can be a constructor parameter for this type ||||
|             |---------|--------|---------|--------|
| This type   | package | parser | control | extern |
|-------------|:-------:|:------:|:-------:|:------:|
| package     | yes     |  no    |  no     |  no    |
| parser      | yes     | yes    |  no     |  no    |
| control     | yes     |  no    | yes     |  no    |
| extern      | yes     | yes    | yes     | yes    |
| table       |  no     |  no    |  no     |  no    |
| value types | yes     | yes    | yes     | yes    |
|-------------|---------|--------|---------|--------|

The next table lists restrictions on what types can be instantiated
where.  The answer for "package" is always "no" because there is no
"inside a package" where instantiations can be written in P4_16.  One
can definitely make constructor calls and use these as parameters when
instantiating a package, and restrictions on those types are in the
table above.

For externs, their implementations are typically written in some other
language, and so what can be instantiated inside of them is not the
concern of the P4_16 language or PSA specifications.

The entries for "value types" are yes for parsers and controls,
because you can define variables of any of those types inside of
parsers and controls.  They may not be defined at the top level of
your program.

|-------------|-------------------------------------------------|
|             | can be instantiated in this place |||||
|             |-----------|---------|---------|---------|--------|
| This type   | top level | package | parser  | control | extern |
|-------------|:---------:|:-------:|:-------:|:-------:|:------:|
| package     | yes       |  no     | no      | no      |  no    |
| parser      |  no[^P4]  |  no     | yes     | no[^P4] |  no    |
| control     |  no[^P4]  |  no     | no[^P4] | yes     |  no    |
| extern      | yes       |  no     | yes     | yes     |  no    |
| table       |  no[^P4]  |  no     | no[^P4] | yes     |  no    |
| value types |  no[^P4]  |  no     | yes     | yes     |  no    |
|-------------|-----------|---------|---------|---------|--------|

[^P4]: This is a limitation in the P4_16 v1.0.0 specification already,
    independent of the PSA.

The next table lists restrictions on what types can be passed as
run-time parameters to other callable things that have run-time
paramters: parsers, controls, extern methods, and actions.

|-------------|-------------------------------------------------|
|             | can be a run-time parameter to this callable thing ||||
|             |-----------|---------|---------|---------|
| This type   | parser    | control | method  | action  |
|-------------|:---------:|:-------:|:-------:|:-------:|
| package     |  no       |  no     | no      | no      |
| parser      |  no       |  no     | no      | no      |
| control     |  no       |  no     | no      | no      |
| extern      | yes       | yes     | yes     | no      |
| table       |  no       |  no     | no      | no      |
| value types | yes       | yes     | yes     | yes     |
|-------------|-----------|---------|---------|---------|

The restrictions on return types of extern methods is the same as for
parameters, with the addition that `void` can be a return type for
methods that return no value.

The next table lists restrictions on what kinds of calls can be made
from which places in a P4 program.  Calling a parser, control, or
table means invoking its `apply()` method.  The row for `extern`
describes where extern method calls can be made from.

|-------------|-------------------------------------------------|
|             | can be called at run time from this place in a P4 program |||||
|             |-----------|---------|---------|------------|--------|
|             |           | control | action  | action not |        |
|             | parser    | apply   | used by | used by    |        |
| This type   | state     | block   | table   | any table  | extern |
|-------------|:---------:|:-------:|:-------:|:----------:|:------:|
| package     | N/A       | N/A     | N/A     | N/A        | N/A    |
| parser      | yes       |  no     | no      | no         | no     |
| control     |  no       | yes     | no      | yes        | no     |
| extern      | yes       | yes     | yes     | yes        | no     |
| table       |  no       | yes     | no      | yes        | no     |
| action      |  no       | yes     | yes     | yes        | no     |
| value types | N/A       | N/A     | N/A     | N/A        | N/A    |
|-------------|-----------|---------|---------|------------|--------|

There may not be any recursion in calls, neither by a thing calling
itself directly, nor mutual recursion.

An extern can never cause any other type of P4 program object to be
called.

An "action used by a table" means an action that is either in the
`actions` list of a table, or it is possible for the action to be
called from such an action, perhaps through one or more intermediate
action calls.

It is allowed to write actions that are not used by any table.  Such
actions can be called from a control `apply` block.  They have exactly
the same restrictions on what they can call as a control `apply` block
does.  Calling such an action is nearly the same as calling another
control, but unlike calling another control, such an action can be
defined within the control that calls it, and thus the action has
access to all parameter values and local variables defined within the
control block that calls the action.

Note that while the extern row shows that extern methods can be called
from many places, particular externs may have additional restrictions
not listed in this table.  For example, the `ValueSet` extern
`is_member` method is only intended to be called from a parser state,
never a control or action.

TBD: All such restrictions should be documented in the description for
each extern.  In most cases, it is expected that the restriction will
be "from a parser state only" or "from a control apply block or action
only".
