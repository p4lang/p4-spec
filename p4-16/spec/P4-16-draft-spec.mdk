Title : P4~16~ Language Specification
Title Note: (version 1.0.0-draft)
Title Footer: &date;
Author : The P4.org language consortium
Heading depth: 5

Pdf Latex: pdflatex
Document Class: [10pt]article
Package: [top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
Package: fancyhdr

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

pre, code {
  language: p4;
}
Colorizer: p4
.token.keyword    {
    font-weight: bold;
    font-family: monospace;
    font-size: 10pt;
}

p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock"
}

@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 10pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 10pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  padding: 10pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  padding: 10pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

[TITLE]

[]{tex-cmd: "\newpage"}
[]{tex-cmd: "\fancyfoot[L]{&date; &time;}"}
[]{tex-cmd: "\fancyfoot[C]{P$4_{16}$ language specification}"}
[]{tex-cmd: "\fancyfoot[R]{\thepage}"}
[]{tex-cmd: "\pagestyle{fancy}"}

~ Begin Abstract
P4 is a language for programming the data plane of network
devices. This document provides a precise definition of the P4~16~
language, which is the 2016 revision of the P4 language
<http://p4.org>.  The target audience for this document includes
developers who want to write compilers, simulators, IDEs, and
debuggers for P4 programs. This document may also be of interest to P4
programmers who are interested in understanding the syntax and
semantics of the language at a deeper level.
~ End Abstract

[TOC]

# Scope { #sec-scope }

This specification document defines the structure and interpretation
of programs in the P4~16~ language. It defines the syntax, semantic
rules, and requirements for conformant implementations of the
language.

It does not define:

- Mechanisms by which P4 programs are compiled, loaded, and executed
  on packet-processing systems,
- Mechanisms by which data are received by one packet-processing
  system and delivered to another system,
- Mechanisms by which the control plane manages the match-action
  tables and other stateful objects defined by P4 programs,
- The size or complexity of P4 programs,
- The minimal requirements of packet-processing systems that are
  capable of providing a conformant implementation.

# Terms, definitions, and symbols

Throughout this document, the following terms will be used:

- **Architecture**: A set of P4-programmable components and the data
  plane interfaces between them.
- **Control plane**: A class of algorithms and the corresponding input
  and output data that are concerned with the provisioning and
  configuration of the data plane.
- **Data plane**: A class of algorithms that describe transformations
  on packets by packet-processing systems.
- **Metadata**: Intermediate data generated during execution of a P4
  program.
- **Packet**: A network packet is a formatted unit of data carried by
  a packet-switched network.
- **Packet header**: Formatted data at the beginning of a packet. A
  given packet may contain a sequence of packet headers representing
  different network protocols.
- **Packet payload**: Packet data that follows the packet headers.
- **Packet-processing system**: A data-processing system oriented
  towards processing network packets. In general, packet-processing
  systems implement control plane and data plane algorithms.
- **Target**: A packet-processing system capable of executing a P4
  program.

All terms defined explicitly in this document should not be understood
to refer implicitly to similar terms defined elsewhere. Terms not
defined explicitly in this document should be interpreted according to
ISO/IEC 2382:2015 (Information Technology - Vocabulary) or the other
generally recognizable sources, such as IETF RFCs.

# Overview

~ Figure { #fig-prgswitch; caption: "Traditional switches vs. programmable switches." }
![prgswitch]
~
[prgswitch]: figs/prgswitch.png { width: 100%; page-align: forcehere }

P4 is a language for expressing how packets are processed by the data
plane of a programmable forwarding element such as a hardware or
software switch, network interface card, router, or network
appliance. The name P4 comes from the original paper that introduced
the language, "Programming Protocol-independent Packet Processors,"
<https://arxiv.org/pdf/1312.1719.pdf>. While P4 was initially designed
for programming switches, its scope has been broadened to cover a
large variety of devices. In the rest of this document we use the
generic term _target_ for all such devices.

Many targets implement both a control plane and a data plane. P4 is
designed to specify only the data plane functionality of the
target. P4 programs also partially define the interface by which the
control plane and the data-plane communicate, but P4 cannot be used to
describe the control-plane functionality of the target. In the rest of
this document, when we talk about P4 as "programming a target", we
mean "programming the data plane of a target".

As a concrete example of a target, Figure [#fig-prgswitch] illustrates
the difference between a traditional fixed-function switch and a
P4-programmable switch. In a traditional switch the manufacturer
defines the data-plane functionality. The control-plane controls the
data plane by managing entries in tables (e.g. routing tables),
configuring specialized objects (e.g. meters), and by processing
control-packets (e.g. routing protocol packets) or asynchronous
events, such as link state changes or learning notifications.

A P4-programmable switch differs from a traditional switch in two
essential ways:

- The data plane functionality is not fixed in advance but is defined
  by the a P4 program. The data plane is configured at initialization
  time to implement the functionality described by the P4 program
  (shown by the long red arrow) and has no built-in knowledge of
  existing network protocols.
- The control plane communicates with the data plane using the same
  channels as in a fixed-function device, but the set of tables and
  other objects in the data plane are no longer fixed, since they are
  defined by a P4 program. The P4 compiler generates the API that the
  control plane uses to communicate with the data plane.

Hence, P4 can be said to be protocol independent, but it enables
programmers to express a rich set of protocols and other data plane
behaviors.

~ Figure { #fig-p4prg; caption: "Programming a target with P4." }
![p4prg]
~
[p4prg]: figs/p4prg.png { width: 100%; page-align: here; }

[]{tex-cmd: "\indent"}
The core abstractions provided by the P4 language are:

- **Header types** describe the format (the set of fields and
  their sizes) of each header within a packet.
- **Parsers** describe the permitted sequences of headers within
  received packets, how to identify those header sequences, and the
  headers and fields to extract from packets.
- **Tables** associate user-defined keys with actions. P4 tables
  generalize traditional switch tables; they can be used to implement
  routing tables, flow lookup tables, access-control lists, and other
  user-defined table types, including complex multivariable decisions.
- **Actions** are code fragments that describe how packet header
  fields and metadata are manipulated. Actions can include data, which
  is supplied by the control-plane at runtime.
- **Match-action units** perform the following sequence of operations:
  * Construct lookup keys from packet fields or computed metadata,
  * Perform table lookup using the constructed key, choosing an action
    (including the associated data) to execute, and
  * Finally, execute the selected action.
- **Control flow** expresses an imperative program that describes
  packet-processing on a target, including the data-dependent sequence
  of match-action unit invocations. Deparsing (packet reassembly) can
  also be performed using a control flow.
- **Extern objects** are architecture-specific constructs that can be
  manipulated by P4 programs through well-defined APIs, but whose
  internal behavior is hard-wired (e.g., checksum units) and hence not
  programmable using P4.
- **User-defined metadata**: user-defined data structures associated
  with each packet.
- **Intrinsic metadata**: metadata provided by the architecture
  associated with each packet---e.g., the input port where a packet
  has been received.

Figure [#fig-p4prg] shows a typical tool workflow when programming a
target using P4.

Target manufacturers provide the hardware or software implementation
framework, an architecture definition, and a P4 compiler for that
target. P4 programmers write programs for a specific architecture,
which defines a set of P4-programmable components on the target as
well as their external data plane interfaces.

Compiling a set of P4 programs produces two artifacts:

- a data plane configuration that implements the forwarding logic
  described in the input program and
- an API for managing the state of the data plane objects from the
  control plane

P4 is a domain-specific language that is designed to be implementable
on a large variety of targets including programmable network interface
cards, FPGAs, software switches, and hardware ASICs. As such, the
language is restricted to constructs that can be efficiently
implemented on all of these platforms.

P4 is not a Turing-complete language. In fact, assuming a fixed cost
for a table lookup operations and interactions with extern objects,
all P4 programs (i.e., parsers and controls) execute a constant number
of operations for each byte of an input packet received and
analyzed. In other words, the computational complexity of a P4 program
is linear in the total size of all headers, and never depends on the
size of the state accumulated while processing data (e.g., the number
of flows, or the total number of packets processed). These guarantees
are necessary (but not sufficient) for enabling fast packet processing
across a variety of targets.

_P4 conformance_ of a target is defined as follows: if a specific
target T supports only a subset of the P4 programming language, say
P4^T^, programs written in P4^T^ executed on the target should provide
the exact same behavior as is described in this document. Note that P4
conformant targets can provide arbitrary P4 language extensions and ```extern```
elements.

## Benefits of P4

Compared to state-of-the-art packet-processing systems (e.g., based on
writing microcode on top of custom hardware), P4 provides a number of
significant advantages:

- **Flexibility**: P4 makes many packet-forwarding policies
  expressible as programs, in contrast to traditional switches, which
  expose fixed-function forwarding engines to their users.
- **Expressiveness**: P4 programs may express sophisticated
  hardware-independent packet processing algorithms using solely
  general-purpose operations and table look-ups. Such programs will be
  portable across hardware targets that implement the same
  architectures (assuming sufficient resources are available).
- **Resource mapping and management**: P4 programs describe storage
  resources abstractly (e.g., IPv4 source address); compilers map such
  user-defined fields to available hardware resources and manage
  low-level details such as allocation and scheduling.
- **Software engineering**: P4 programs provide important benefits
  such as type checking, information hiding, and software reuse.
- **Component libraries**: Manufacturer-supplied component libraries
  can be used to wrap hardware-specific functions into portable
  high-level P4 constructs.
- **Decoupling hardware and software evolution**: Target manufacturers
  may use abstract architectures to further decouple the evolution of
  low-level architectural details from high-level processing.
- **Debugging**: Manufacturers can provide software models of an
  architecture to aid in the development and debugging of P4 programs.

## P4 language evolution: comparison to previous versions (P4 v1.0/v1.1)

~ Figure { #fig-p4transition; caption: "Evolution of the language between versions P4~14~ (versions 1.0 and 1.1) and P4~16~." }
![p4transition]
~
[p4transition]: figs/p4transition.png { width: 100%; page-align: forcehere }

Compared to P4~14~, the previous version of the language, P4~16~ makes
a number of significant, backwards-incompatible changes to the syntax
and semantics of the language. The evolution from the previous version
(P4~14~) to the current one (P4~16~) is depicted in Figure
[#fig-p4transition]. In particular, a large number of language
features have been eliminated from the language and moved into
libraries including counters, checksum units, meters, etc.

Hence, the language has been transformed from a complex language (74
keywords) into a relatively small core language (35 keywords, shown in
Section [#sec-p4-keywords]) accompanied by a library of fundamental
constructs that are needed for writing most P4.

The v1.1 version of P4 introduced a language construct called ```extern``` that
can be used to describe library elements. Many constructs defined in the
v1.1 language specification will thus be transformed into such
library elements (including constructs that have been eliminated
from the language, such as counters and meters). Some of these ```extern``` objects
are expected to be standardized, and they will be in the scope of a
future document describing a standard library of P4 elements. In
this document we provide several examples of ```extern``` constructs.
P4~16~ also introduces and repurposes some v1.1 language
constructs for describing the programmable parts of an
architecture. These language constructs are: ```parser```, ```state```, ```control```, and ```package```.

One important goal of the P4~16~ language revision is to provide a
*stable* language definition. In other words, we strive to ensure that
all programs written in P4~16~ will remain syntactically correct and
behave identically when treated as programs for future versions of the
language. Moreover, if some future version of the language requires
breaking backwards compatibility, we will seek to provide an easy path
for migrating P4~16~ programs to the new version.

# Architecture Model { #sec-arch }

~ Figure { #fig-p4interface; caption: "P4 program interfaces." }
![p4interface]
~
[p4interface]: figs/p4interface.png { width: 100%; page-align: here }

The _P4 architecture_ identifies the P4-programmable blocks (e.g.,
parser, ingress control flow, egress control flow, deparser, etc.) and their
data plane interfaces.

The P4 architecture can be thought of as a contract between the
program and the target.
Each manufacturer must therefore
provide both a P4 compiler as well as an accompanying
architecture definition for their target. (We expect that P4 compilers
can share a common front-end that handles all architectures). The architecture
definition does not have to expose the entire programmable surface of
the data plane---a manufacturer may even choose to provide multiple
definitions for the same hardware device, each with different
capabilities (e.g., with or without multicast support).

Figure [#fig-p4interface] illustrates the data plane interfaces between P4-programmable
blocks. It shows a target that has two programmable blocks (#1 and #2).
Each block is programmed through a separate fragment of P4 code. The
target interfaces with the P4 program through a set of control
registers or signals. Input controls provide information to P4
programs (e.g., the input port that a packet was received from), while
output controls can be written to by P4 programs to influence the
target behavior (e.g., the output port where a packet has to be
directed). Control registers/signals are represented in P4 as
_intrinsic metadata_.
P4 programs can also store and manipulate data pertaining to each
packet as _user-defined metadata_.

The behavior of a P4 program can be fully described in terms of
transformations that map vectors of bits to vectors of bits. To actually
process a packet, the architecture
model interprets the bits that the P4 program writes to intrinsic metadata.
For example, to cause a packet to
be forwarded on a specific output port, a P4 program may need to write
the index of an output port into a dedicated control register. Similarly,
to cause a packet to be dropped, a P4 program may need to set a
"drop" bit into another dedicated control register. Note that the details of
how intrinsic metadata are interpreted is architecture-specific.

~ Figure { #fig-p4checksum; caption: "P4 program invoking the services of a fixed-function object." }
![p4checksum]
~
[p4checksum]: figs/p4checksum.png { width: 50%; page-align: here }

[]{tex-cmd: "\indent"}
P4 programs can invoke services implemented by extern objects and functions provided by the architecture.
Figure [#fig-p4checksum] depicts a P4 program invoking the services of a
built-in checksum computation unit on a target. The implementation of the checksum
unit is not specified in P4, but its interface is. In general, the interface for
an extern object describes each operation it provides, as well as their parameter and return types.

In general, P4 programs are not expected to be portable across
different architectures. For example, executing a P4 program that
broadcasts packets by writing into a custom control register
will not function correctly on a target that does not have the control
register. However, P4 programs written for a given architecture should
be portable across all targets that faithfully implement the
corresponding model, provided there are sufficient resources.

## Standard architectures { #sec-p4-std-arch }

We expect that the P4 community will evolve a small set of standard architecture
models pertaining to specific verticals. Wide adoption of such standard
architectures will promote portability of P4 programs across different targets.
However, defining these
standard architectures is outside of the scope of this document.

## Data plane interfaces { #sec-dp-interfaces }

To describe a functional block that can be programmed in P4, the
architecture includes a type declaration that specifies the interfaces
between the block and the other components in the architecture.
For example, the architecture might contain a declaration such as the following:

~ Begin P4Example
control MatchActionPipe<H>(in bit<4> inputPort,
                           inout H parsedHeaders,
                           out bit<4> outputPort);
~ End P4Example

This type declaration describes a block named ```MatchActionPipe```
that can be programmed using a data-dependent sequence of match-action
unit invocations and other imperative constructs (indicated by the ```control```
keyword).  The interface between the ```MatchActionPipe``` block and
the other components of the architecture can be read off from this declaration:

- The first parameter is a 4-bit value named ```inputPort.``` The
  direction ```in``` indicates that this parameter is an input that
  cannot be modified.
- The second parameter is an object of type ```H``` named ```parsedHeaders```,
  where ```H``` is a type variable representing the headers that will
  be defined later by the P4 programmer.
  The direction ```inout``` indicates that this parameter is
  both an input and an output.
- The third parameter is a 4-bit value named ``outputPort```. The
  direction ```out``` indicates that this parameter is an output
  whose value is undefined initially but can be modified.

## Extern objects and functions { #sec-external-units }

P4 programs can also interact with objects and functions provided by the architecture.
Such objects are described using the ```extern``` construct, which
describes the interfaces that such objects expose to the data-plane.

An ```extern``` object describes a set of methods that are implemented
by an object, but not the implementation of these methods (i.e., it is similar
to an abstract class in an object-oriented language). For example,
the following construct could be used to describe the operations offered by an
incremental checksum unit:

~ Begin P4Example
extern Checksum16 {
    Checksum16();              // constructor
    void clear();              // prepare unit for computation
    void update<T>(in T data); // add data to checksum
    void remove<T>(in T data); // remove data from existing checksum
    bit<16> get(); // get the checksum for the data added since last clear
}
~ End P4Example

# Example: A very simple switch { #sec-vss-example }

As an example to illustrate the features of architectures, consider
implementing a very simple switch in P4. We will first describe the
architecture of the switch and then write a complete P4 program
that specifies the data plane behavior of the switch. This example
demonstrates many important features of the P4 programming language.

~ Figure { #fig-vssarch; caption: "The Very Simple Switch (VSS) architecture." }
![vssarch]
~
[vssarch]: figs/vssarch.png { width: 100%; page-align: here }

[]{tex-cmd: "\indent"}
We call our architecture the "Very Simple Switch" (VSS). Figure
[#fig-vssarch] is a diagram of this architecture. There is nothing inherently
special about VSS---it is just a pedagogical example that
illustrates how programmable switches can be described and programmed
in P4. VSS has a number of fixed-function blocks (shown in cyan in our
example), whose behavior is described in Section [#sec_vssarch]. The
white blocks are programmable using P4.

VSS receives packets through one of 8 input Ethernet ports, through a
recirculation channel, or from a port connected directly to the
CPU. VSS has one single parser, feeding into a single match-action
pipeline, which feeds into a single deparser. After exiting the
deparser, packets are emitted through one of 8 output Ethernet ports
or one of 3 "special" ports:

- Packets sent to the "CPU port" are sent to the control plane
- Packets sent to the "Drop port" are discarded
- Packets sent to the "Recirculate port" are re-injected in the switch
  through a special input port

The white blocks in the figure are programmable, and the user must
provide a corresponding P4 program to specify the behavior of each
such block. The red arrows indicate the flow of user-defined data.  The
cyan blocks are fixed-function components. The green arrows are data plane
interfaces used to convey information between the fixed-function
blocks and the programmable blocks---exposed in the P4 program as
intrinsic metadata.

## Very Simple Switch Architecture { #sec-vss-arch }

The following P4 program provides a declaration of VSS in P4, as it
would be provided by the VSS manufacturer. The declaration contains
several type declarations, constants, and finally declarations for the
three programmable blocks; the code uses syntax highlighting. The
programmable blocks are described by their types; the implementation
of these blocks has to be provided by the switch programmer.

~ Begin P4Example
// File "very_simple_switch_model.p4"
// Simple switch P4 declaration
// core library needed for packet_in definition
# include <core.p4>
/* Various constants and structure declarations */
/* ports are represented using 4-bit values */
typedef bit<4> PortId;
/* only 8 ports are "real" */
const PortId REAL_PORT_COUNT = 4w8;  // 4w8 is the number 8 in 4 bits
/* metadata accompanying an input packet */
struct InControl {
    PortId inputPort;
}
/* special input port values */
const PortId RECIRCULATE_IN_PORT = 0xD;
const PortId CPU_IN_PORT = 0xE;
/* metadata that must be computed for outgoing packets */
struct OutControl {
    PortId outputPort;
}
/* special output port values for outgoing packet */
const PortId DROP_PORT = 0xF;
const PortId CPU_OUT_PORT = 0xE;
const PortId RECIRCULATE_OUT_PORT = 0xD;
/* Prototypes for all programmable blocks */
/**
 * Programmable parser.
 * @param <H> type of headers; defined by user
 * @param b input packet
 * @param parsedHeaders headers constructed by parser
 */
parser Parser<H>(packet_in b,
                 out H parsedHeaders);
/**
 * Match-action pipeline
 * @param <H> type of input and output headers
 * @param headers headers received from the parser and sent to the deparser
 * @param parseError error that may have surfaced during parsing
 * @param inCtrl information from architecture, accompanying input packet
 * @param outCtrl information for architecture, accompanying output packet
 */
control Pipe<H>(inout H headers,
                in error parseError,// parser error
                in InControl inCtrl,// input port
                out OutControl outCtrl); // output port
/**
 * Switch deparser.
 * @param <H> type of headers; defined by user
 * @param b output packet
 * @param outputHeaders headers for output packet
 */
control Deparser<H>(inout H outputHeaders,
                    packet_out b);
/**
 * Top-level package declaration - must be instantiated by user.
 * The arguments to the package indicate blocks that
 * must be instantiated by the user.
 * @param <H> user-defined type of the headers processed.
 */
package VSS<H>(Parser<H> p,
               Pipe<H> map,
               Deparser<H> d);
// Architecture-specific objects that can be instantiated
// Checksum unit
extern Checksum16 {
    Checksum16();              // constructor
    void clear();              // prepare unit for computation
    void update<T>(in T data); // add data to checksum
    void remove<T>(in T data); // remove data from existing checksum
    bit<16> get(); // get the checksum for the data added since last clear
}
~ End P4Example
Let us describe some of these elements:

- The included file ```core.p4``` is described in more detail in
  Appendix [#sec-p4-core-lib]. It defines some standard
  data-types and error codes.
- ```bit<4>``` is the type of bit-strings with 4 bits.
- The syntax ```4w0xF``` indicates the value 15 represented using 4
  bits. An alternative notation is ```4w15```. In many circumstances
  the width modifier can be omitted, writing just ```15```.
- ```error``` is a built-in P4 type for holding error codes
- Next follows the declaration of a parser:
~ Begin P4Example
parser Parser<H>(packet_in b, out H parsedHeaders);
~ End P4Example

This declaration describes the interface for a parser, but not yet its
implementation, which will be provided by
the programmer. The parser reads its input from a ```packet_in```, which is
a pre-defined P4 extern object that represents an incoming
packet, declared in the ```core.p4``` library. The parser writes its
output (the ```out``` keyword) into the ```parsedHeaders```
argument. The type of this argument is ```H```, yet unknown---it will
also be provided by the programmer.

- The declaration
~ Begin P4Example
control Pipe<H>(inout H headers,
                in error parseError,
                in InControl inCtrl,
                out OutControl outCtrl);
~ End P4Example
describes the interface of a Match-Action pipeline named ```Pipe```.

The pipeline receives three inputs: the headers ```headers```, a parser
error ```parseError```, and the ```inCtrl``` control data. Figure
[#fig-vssarch] indicates the different sources of these pieces of
information. The pipeline writes its outputs into ```outCtrl```, and
it must update in place the headers to be consumed by the deparser.

- The top-level package is called ```VSS```; in order to program a
  VSS, the user will have to instantiate a package of this type (shown
  in the next section). The top-level package declaration also depends
  on a type variable H:
~ Begin P4Example
package VSS<H>
~ End P4Example

A type variable indicates a type yet unknown that must be provided by
the user at a later time. In this case ```H``` is the type of the set
of headers that the user program will be processing; the parser will
produce the parsed representation of these headers, and the
match-action pipeline will update the input headers in place to
produce the output headers.

- The ```package VSS``` declaration has three complex parameters, of
  types ```Parser```, ```Pipe```, and ```Deparser``` respectively; which are
  exactly the declarations we have just described. In order to program
  the target one has to supply values for these parameters.
- In this program the ```inCtrl``` and ```outCtrl``` structures
  represent control registers. The content of the headers structure is
  stored in general-purpose registers.
- The ```extern Checksum16``` declaration describes an extern object
  whose services can be invoked to compute checksums.

## Very Simple Switch Architecture Description { #sec_vssarch }

In order to fully understand VSS's behavior and write meaningful P4
programs for it, and for implementing a control plane, we also need a
full behavioral description of the fixed-function blocks. This section
can be seen as a simple example illustrating all the details that have
to be handled when writing an architecture description. The P4
language is not intended to cover the description of all such
functional blocks---the language can only describe the interfaces
between programmable blocks and the architecture. For the current program,
this interface is given by the ```Parser```, ```Pipe```, and ```Deparser```
declarations. In practice we expect that the complete description of the architecture
will be provided as an executable program and/or diagrams and text; in
this document we will provide informal descriptions in English.

### Arbiter block

The input arbiter block performs the following functions:

- It receives packets from one of the physical input Ethernet ports,
  from the control plane, or from the input recirculation port.
- For packets received from Ethernet ports, the block computes the
  Ethernet trailer checksum and verifies it. If the checksum does not
  match, the packet is discarded. If the checksum does match, it is
  removed from the packet payload.
- Receiving a packet involves running an arbitration algorithm if
  multiple packets are available.
- If the arbiter block is busy processing a previous packet and no
  queue space is available, input ports may drop arriving packets,
  without indicating the fact that the packets were dropped in any
  way.
- After receiving a packet, the arbiter block sets the ```inCtrl.inputPort```
  value that is an input to the parser with the identity of the input
  port where the packet originated. Physical Ethernet ports are
  numbered 0 to 7, while the input recirculation port has a number 13
  and the CPU port has the number 14.

### Parser runtime block

The parser runtime block works in concert with the parser. It provides
an error code to the match-action pipeline, based on the parser
actions, and it provides information about the packet payload (e.g.,
the size of the remaining payload data) to the demux block. As soon as
a packet's processing is completed by the parser, the match-action
pipeline is invoked with the associated metadata as inputs (packet
headers and user-defined metadata).

### Demux block

The core functionality of the demux block is to receive the headers
for the outgoing packet from the deparser and the packet payload from
the parser, to assemble them into a new packet and to send the result
to the correct output port. The output port is specified by the value
of ```outCtrl.ouputPort```, which is set by the match-action pipeline.

- Sending the packet to the drop port causes the packet to disappear.
- Sending the packet to an output Ethernet port numbered between 0 and
  7 causes it to be emitted on the corresponding physical
  interface. The packet may be placed in a queue if the output
  interface is already busy emitting another packet. When the packet is
  emitted, the physical interface computes a correct Ethernet checksum
  trailer and appends it to the packet.
- Sending a packet to the output CPU port causes the packet to be
  transferred to the control plane. In this case, the packet that is
  sent to the CPU is the **original input packet**, and not the packet
  received from the deparser---the latter packet is discarded.
- Sending the packet to the output recirculation port causes it to
  appear at the input recirculation port. Recirculation is useful when
  packet processing cannot be completed in a single pass.
- If the ```outputPort``` has an illegal value (e.g., 9), the packet
  is dropped.
- Finally, if the demux unit is busy processing a previous packet and there is
  no capacity to queue the packet coming from the deparser, **the
  demux unit may drop the packet**, irrespective of the output port indicated.

Please note that some of the behaviors of the demux block may be
unexpected---we have highlighted them in bold. We are not specifying
here several important behaviors related to queue size, arbitration,
and timing, which also influence the packet processing.

The arrow shown from the parser runtime to the demux block represents
an additional information flow from the parser to the demux: the
packet being processed as well as the offset within the packet where
parsing ended (i.e., the start of the packet payload).

### Available extern blocks { #sec-vss-extern }

The VSS architecture provides an incremental checksum extern block,
called ```Checksum16```. The checksum unit has a constructor and four
methods:

- ```clear()```: prepares the unit for a new computation
- ```update<T>(in T data)```: add some data to be checksummed. The
  data must be either a bit-string, a header-typed value, or a ```struct```
  containing such values. The fields in the header/struct
  are concatenated in the order they appear in the type declaration.
- ```get()```: returns the 16-bit one's complement checksum. When
  this function is invoked the checksum must have received an integral
  number of bytes of data.
- ```remove<T>(in T data)```: assuming that ```data```
  was used for computing the current checksum, ```data``` is removed
  from the checksum.

## A complete Very Simple Switch program { #sec-vss-all }

Here we provide a complete P4 program that implements basic forwarding for
IPv4 packets on the VSS architecture. This program does not utilize all of the
features provided by the architecture---e.g., recirculation---but it does use
preprocessor ```#include``` directives (see Section [#sec-preprocessor]).

~ Figure { #fig-vssmau; caption: "Diagram of the match-action pipeline expressed by the VSS P4 program." }
![vssmau]
~
[vssmau]: figs/vssmau.png { width: 100%; page-align: here }

[]{tex-cmd: "\indent"}
The parser attempts to recognize an Ethernet header followed by an IPv4 header.
If either of these headers are missing, parsing terminates with an
error. Otherwise it extracts the information from these headers into a
```Parsed_packet``` structure. The match-action pipeline is
shown in Figure [#fig-vssmau]; it comprises four match-action units
(represented by the P4 ```table``` keyword):

- If any parser error has occurred, the packet is dropped (i.e., by assigning ```outputPort```
  to ```DROP_PORT```)
- The first table uses the IPv4 destination address to determine the ```outputPort```
  and the IPv4 address of the next hop. If this lookup fails, the packet is dropped.
  The table also decrements the IPv4 ```ttl``` value.
- The second table checks the ```ttl``` value: if the ```ttl``` becomes 0, the
  packet is sent to the control plane through the CPU port.
- The third table uses the IPv4 address of the next hop (which was computed by
  the first table) to determine the Ethernet address of the next hop.
- Finally, the last table uses the ```outputPort``` to identify the
  source Ethernet address of the current switch, which is set in the
  outgoing packet.

The deparser constructs the outgoing packet by reassembling the Ethernet and
IPv4 headers as computed by the pipeline.

~ Begin P4Example
// Include P4 core library
# include <core.p4>

// Include very simple switch architecture declarations
# include "very_simple_model.p4"

// This program processes packets comprising an Ethernet and an IPv4
// header, and it forwards packets using the destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// Standard Ethernet header
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header (without options)
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Structure of parsed headers
struct Parsed_packet {
    Ethernet_h ethernet;
    IPv4_h     ip;
}

// Parser section

// User-defined errors that may be signaled during parsing
error {
    IPv4OptionsNotSupported,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

parser TopParser(packet_in b, out Parsed_packet p) {
    Checksum16() ck;  // instantiate checksum unit

    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            0x0800: parse_ipv4;
            // no default rule: all other packets rejected
        }
    }

    state parse_ipv4 {
        b.extract(p.ip);
        verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
        verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
        ck.clear();
        ck.update(p.ip);
        // Verify that packet checksum is zero
        verify(ck.get() == 16w0, error.IPv4ChecksumError);
        transition accept;
    }
}

// Match-action pipeline section

control TopPipe(inout Parsed_packet headers,
                in error parseError, // parser error
                in InControl inCtrl, // input port
                out OutControl outCtrl) {
     IPv4Address nextHop;  // local variable

     /**
      * Indicates that a packet is dropped by setting the
      * output port to the DROP_PORT
      */
      action Drop_action() {
          outCtrl.outputPort = DROP_PORT;
      }

     /**
      * Set the next hop and the output port.
      * Decrements ipv4 ttl field.
      * @param ivp4_dest ipv4 address of next hop
      * @param port output port
      */
      action Set_nhop(IPv4Address ipv4_dest, PortId port) {
          nextHop = ipv4_dest;
          headers.ip.ttl = headers.ip.ttl - 1;
          outCtrl.outputPort = port;
      }

     /**
      * Computes address of next IPv4 hop and output port
      * based on the IPv4 destination of the current packet.
      * Decrements packet IPv4 TTL.
      * @param nextHop IPv4 address of next hop
      */
     table ipv4_match {
         key = { headers.ip.dstAddr: lpm; }  // longest-prefix match
         actions = {
              Drop_action;
              Set_nhop;
         }
         size = 1024;
         default_action = Drop_action;
     }

     /**
      * Send the packet to the CPU port
      */
      action Send_to_cpu() {
          outCtrl.outputPort = CPU_OUT_PORT;
      }

     /**
      * Check packet TTL and send to CPU if expired.
      */
     table check_ttl {
         key = { headers.ip.ttl: exact; }
         actions = { Send_to_cpu; NoAction; }
         const default_action = NoAction; // defined in core.p4
     }

     /**
      * Set the destination MAC address of the packet
      * @param dmac destination MAC address.
      */
      action Set_dmac(EthernetAddress dmac) {
          headers.ethernet.dstAddr = dmac;
      }

     /**
      * Set the destination Ethernet address of the packet
      * based on the next hop IP address.
      * @param nextHop IPv4 address of next hop.
      */
      table dmac {
          key = { nextHop: exact; }
          actions = {
               Drop_action;
               Set_dmac;
          }
          size = 1024;
          default_action = Drop_action;
      }

      /**
       * Set the source MAC address.
       * @param smac: source MAC address to use
       */
       action Set_smac(EthernetAddress smac) {
           headers.ethernet.srcAddr = smac;
       }

      /**
       * Set the source mac address based on the output port.
       */
      table smac {
           key = { outCtrl.outputPort: exact; }
           actions = {
                Drop_action;
                Set_smac;
          }
          size = 16;
          default_action = Drop_action;
      }

      apply {
          if (parseError != error.NoError) {
              Drop_action();  // invoke drop directly
              return;
          }

          ipv4_match.apply(); // Match result will go into nextHop
          if (outCtrl.outputPort == DROP_PORT) return;

          check_ttl.apply();
          if (outCtrl.outputPort == CPU_OUT_PORT) return;

          dmac.apply();
          if (outCtrl.outputPort == DROP_PORT) return;

          smac.apply();
    }
}

// deparser section
control TopDeparser(inout Parsed_packet p, packet_out b) {
    Checksum16() ck;
    apply {
        b.emit(p.ethernet);
        if (p.ip.isValid()) {
            ck.clear();              // prepare checksum unit
            p.ip.hdrChecksum = 16w0; // clear checksum
            ck.update(p.ip);         // compute new checksum.
            p.ip.hdrChecksum = ck.get();
        }
        b.emit(p.ip);
    }
}

// Instantiate the top-level VSS package
VSS(TopParser(),
    TopPipe(),
    TopDeparser()) main;
~ End P4Example

# P4 language definition { #sec-p4-lang-def }

The P4 language can be viewed as having several distinct components,
which we describe separately:

- The core language, comprising of types, variables, scoping,
  declarations, statements, expressions, etc. We start by describing
  this part of the language.
- A sub-language for expressing parsers, based on state machines
  (Section [#sec-packet-parsing]).
- A sub-language for expressing match-action computations, based on
  traditional imperative control-flow (Section [#sec-control]).
- A sub-language for describing architectures (Section
  [#sec-arch-desc]).

## Syntax and semantics { #sec-syntax }

### Grammar { #sec-grammar-intro }

The complete grammar of P4~16~ is given in Appendix [#sec-grammar],
using Yacc/Bison grammar description language. This text is based on
the same gramar. We adopt several standard conventions when we provide
excerpts from the grammar:

- ```UPPERCASE``` symbols denote terminals in the grammar.
- Excerpts from the grammar are given in BNF notation as follows:
~ Begin P4Grammar
p4program
    : /* empty */
    | p4program declaration
    | p4program ';'
    ;
~ End P4Grammar

Pseudo-code (mostly used for describing the semantics of
various P4 constructs) are shown with fixed-size fonts as in the
following example:

~ Begin P4Pseudo
ParserModel.verify(bool condition, error err) {
    if (condition == false) {
        ParserModel.parserError = err;
        ParserModel.currentState = reject;
    }
}
~ End P4Pseudo

### Semantics and the P4 abstract machines

We describe the semantics of P4 in terms of abstract machines executing
traditional imperative code. There is an abstract machine for each P4
sub-language (parser, control). The abstract machines are described in
this text in pseudo-code and English.

P4 compilers are free to reorganize the code they generate in any way as long as
the externally visible behaviors of the P4 programs are preserved as
described by this specification where externally visible behavior is defined as:

- The input/output behavior of all P4 blocks, i.e., the values of the
  outputs computed by a P4 parser/control block given a set of inputs, and
- The state maintained by extern blocks.

## Preprocessing { #sec-preprocessor }

To aid composition of programs from multiple source files P4
compilers should support the following subset of the C preprocessor
functionality:

-	```#define``` for defining macros (without arguments)
-	```#undef```
-	```#if #else #endif #ifdef #ifndef #elif```
-	```#include```

The preprocessor should also remove the sequence backslash newline (ASCII codes 92, 10)
to facilitate splitting content across multiple lines when convenient for formatting.

Additional capabilities of the C preprocessor may be supported, but
are not guaranteed (e.g., macros with arguments).  Similar to C, ```#include```
can specify a file name either within double quotes or within ```<>```.

~ Begin P4Example
# include <system_file>
# include "user_file"
~ End P4Example

The difference between the two forms is the order in which the
preprocessor searches for header files when the path is incompletely
specified.

P4 compilers should correctly handle ```#line``` directives
that may be generated during preprocessing.  This functionality allows
P4 programs to be built from multiple source files, potentially
produced by different programmers at different times:

- the P4 core library, defined in this document,
- the architecture, defining data plane interfaces and extern blocks,
- user-defined libraries of useful components (e.g. standard
  protocol header definitions), and
- the P4 programs that specify the behavior of each programmable block.

### P4 core library

The P4 language specification defines a core library that includes
several common programming constructs. A
description of the core library is provided in Appendix
[#sec-p4-core-lib]. Most P4 programs will include the core
library. Including the core library is done with

~ Begin P4Example
# include <core.p4>
~ End P4Example

## Lexical constructs { #sec-lexical }

All P4 keywords use only ASCII characters. All P4 identifiers must use
only ASCII characters. P4 compilers should handle correctly strings
containing 8-bit characters in comments and string literals.
P4 is case-sensitive.
Whitespace characters, including newlines are treated as token
separators. Indentation is free-form; however, P4 has C-like block
constructs, and all our examples use C-style indentation. Tab
characters are treated as spaces.

The lexer recognizes the following kinds of terminals:

- ```IDENTIFIER```: start with a letter or underscore, and contain
  letters, digits and underscores
- ```TYPE```: identifier that denotes a type name
- ```INTEGER```: integer literals
- ```DONTCARE```: a single underscore
- Keywords such as ```RETURN```. By convention, each keyword terminal corresponds to a
  language keyword with the same spelling but using lowercase. For
  example, the ```RETURN``` terminal corresponds to the ```return```
  keyword.

### Identifiers { #sec-identifiers }

P4 identifiers may contain only letters, numbers, and the underscore
character ```_```, and must start with a letter or
underscore. The special identifier consisting of a single underscore ```_```
is reserved to indicate a "don't care" value; its
type may vary depending on the context. Certain keywords (e.g., ```apply```)
can be used as identifiers if the context makes it unambiguous.

~ Begin P4Grammar
nonTypeName
    : IDENTIFIER
    | APPLY
    | KEY
    | ACTIONS
    | STATE
    ;

name
    : nonTypeName
    | TYPE
    ;
~ End P4Grammar

### Comments { #sec-comments }

P4 supports several kinds of comments:

- Single-line comments, introduced by ```//``` and spanning to the end of line,
- Multi-line comments, enclosed between ```/*``` and ```*/```
- Nested multi-line comments are not supported.
- Javadoc-style comments, starting with ```/**``` and ending with ```*/```

Use of Javadoc-style comments is strongly encouraged for the tables and actions
that are used to synthesize the interface with the control-plane.

P4 treats comments as token separators and no comments are allowed within a
token---e.g. ```bi/**/t``` is parsed as two tokens, ```bi``` and ```t```, and
not as a single token ```bit```.

### Literal constants { #sec-literals }

#### Boolean literals { #sec-boolean-literals }

There are two boolean literal constants: ```true``` and ```false```.

#### Integer literals { #sec-integer-literals }

Integer literals are positive, arbitrary-precision integers. By
default, literals are represented in base 10. To use a different base for
the literal, one of the following prefixes must be employed:

- ```0x``` or ```0X``` indicates base 16 (hexadecimal)
- ```0o``` or ```0O``` indicates base 8 (octal)
- ```0b``` or ```0B``` indicates base 2

The width of a numeric literal in bits can be specified by an unsigned
number prefix consisting of a number of bits and a signedness
indicator:

- ```w``` indicates unsigned numbers
- ```s``` indicates signed numbers

Note that a leading zero by itself does not indicate an
octal (base 8) constant.  The underscore character is considered a
digit within number literals but is ignored when computing the
value of the parsed number. This allows long constant numbers to be
more easily read by grouping digits together. The underscore cannot be
used in the width specification or as the first character of an
integer literal. No comments or whitespaces are allowed within a
literal. Here are some examples of numeric literals:

~ Begin P4Example
32w0xFF        // a 32-bit unsigned number with value 255
32s0xFF        // a 32-bit signed number with value 255
8w0b10101010   // an 8-bit unsigned number with value 0xAA
8w0b_1010_1010 // same value as above
8w170          // same value as above
8s0b1010_1010  // an 8-bit signed number with value -86
16w0377        // 16-bit unsigned number with value 377 (not 255!)
16w0o377       // 16-bit unsigned number with value 255 (base 8)
~ End P4Example

#### String literals { #sec-string-literals }

String literals (string constants) are specified as an arbitrary
sequence of 8-bit characters, enclosed within double quote signs ```"```
(ASCII code 34). Strings start with a double quote sign
and extend to the first double quote sign which is not immediately
preceded by an odd number of backslash characters (ASCII code 92). P4
does not make any validity checks on strings (i.e., it does not check
that strings represent legal UTF-8 encodings).

Since P4 does not provide any operations on strings,
string literals are generally passed unchanged through the P4 compiler to
other third-party tools or compiler-backends, including the
terminating quotes. These tools can define their own handling of
escape sequences (e.g., how to specify Unicode characters, or handle
unprintable ASCII characters).

Here are 3 examples of string literals:
~ Begin P4Example
"simple string"
"string \" with \" embedded \" quotes"
"string with embedded line terminator"
~ End P4Example

## Naming conventions { #sec-naming-conventions }

P4 provides a rich assortment of types. Base types include bit-strings, numbers, and errors.
There are also built-in types for
representing constructs such as parsers, pipelines, actions, and
tables. Users can
construct new types based on these: structures, enumerations, headers,
header stacks, header unions, etc.

In this document we adopt the following conventions:

- Built-in types are written with lowercase characters---e.g., ```int<20>```,
- User-defined types are capitalized---e.g., ```IPv4Address```,
- Type variables are always uppercase---e.g., ```parser P<H, IH>(...)```,
- Variables are uncapitalized--- e.g., ```ipv4header```,
- Constants are written with uppercase characters---e.g., ```CPU_PORT```, and
- Errors and enumerations are written in camel-case--- e.g. ```PacketTooShort```.

## P4 programs { #sec-p4-prog-structure }

A P4 program is a list of declarations:

~ Begin P4Grammar
p4program
    : /* empty */
    | p4program declaration
    | p4program ';'  /* empty declaration */
    ;

declaration
    : constantDeclaration
    | externDeclaration
    | actionDeclaration
    | parserDeclaration
    | typeDeclaration
    | controlDeclaration
    | instantiation
    | errorDeclaration
    | matchKindDeclaration
    ;
~ End P4Grammar

An empty declarations is indicated with a single semicolon. (Allowing empty
declarations accommodates the
habits of C/C++ and Java programmers---e.g., certain constructs, like ```struct```,
do not require a terminating semicolon).

### Scopes { #sec-scopes }

Some P4 constructs act as namespaces that create local scopes for names including:

- Derived type declarations (```struct```, ```header```, ```header_union```, ```enum```),
  which introduce local scopes for field names,
- Block statements, which introduce local lexically-enclosed scopes,
- ```parser```, ```table```, ```action```, and ```control``` blocks, which
  introduce local scopes
- Declarations with type variables, which introduce a new scope for those
  variables. For example, in the following ```extern``` declaration,
  the scope of the type variable ```H``` extends to the end of the
  declaration:

~ Begin P4Example
extern E<H>(...) { ... } // scope of H ends here.
~ End P4Example

The order of declarations is important; with the exception of parser
states, all uses of a symbol must follow the symbol's
declaration. (This is a departure from P4~14~, which
allows declarations in any order. This requirement significantly simplifies the implementation of
compilers for P4, allowing compilers to use additional information
about declared identifiers to resolve ambiguities.)

### Stateful elements { #sec-stateful-elems }

Most P4 constructs are stateless: given some inputs they produce a
result that solely depends on these inputs. There are only two stateful constructs
that may retain information across packets:

- ```table```s" Tables are read-only for the data plane, but their
  entries can be modified by the control-plane,
- ```extern``` objects: many objects have state that can be read and
  written by the control plane and data plane. All constructs from the P4~14~ language
  version that encapsulate state (e.g., counters, meters, registers) are
  represented using ```extern``` objects in P4~16~.

In P4 all stateful elements must be explicitly allocated at
compilation-time through the process called "instantiation".

In addition, ```parser```s, ```control``` blocks, and ```package```s
may contain stateful element instantiations. Thus, they are also
treated as stateful elements, even if they appear to contain no state,
and must be instantiated before they can be used. However, although
they are stateful, ```table```s do not need to be instantiated
explicitly---declaring a ```table``` also creates an instance of
it. This convention is designed to support the common case, since most
tables are used just once. To have finer-grained control over when a
```table``` is instantiated, a programmer can declare it within a
```control```.

Recall the example in Section [#sec-vss-all]: ```TopParser```, ```TopPipe```, ```TopDeparser```, ```Checksum16```,
and ```Switch``` are types. There are two instances of ```Checksum16```, one in ```TopParser``` and
one in ```TopDeparser```, both called ```ck```. The ```TopParser```, ```TopDeparser```, ```TopPipe```,
and ```Switch``` are instantiated at the end of the program, in the
declaration of the ```main``` instance object, which is an instance of
the ```Switch``` type (a ```package```).

## L-values { #sec-lvalues }

L-values are expressions that may appear on the left side of an
assignment operation or as arguments corresponding to ```out``` and ```inout```
function parameters. An l-value represents a storage reference.  The
following expressions are legal l-values:

~ Begin P4Grammar
prefixedNonTypeName
    : nonTypeName
    | dotPrefix nonTypeName
    ;

lvalue
    : prefixedNonTypeName
    | lvalue '.' member
    | lvalue '[' expression ']'
    | lvalue '[' expression ':' expression ']'
    ;
~ End P4Grammar

- Identifiers of a base or derived type.
- Structure, header, and header union field member access operations
  (using the dot notation).
- References to elements within header stacks (see Section
  [#sec-expr-hs]): indexing, and references to ```last``` and ```next```.
- The result of a bit-slice operator ```[m:l]```.

The following is a legal l-value: ```headers.stack[4].field```.  Note
that method and function calls cannot return l-values.

## Calling convention: call by copy in/copy out { #sec-calling-convention }

P4 provides multiple constructs for writing modular programs: extern
methods, parsers, controls, actions. All these constructs behave
similarly to procedures in standard general-purpose programming languages:

- They have named and typed parameters.
- They introduce a new local scope for parameters and local variables.
- They allow arguments to be passed by binding them to their
  parameters.

Invocations are executed using copy-in/copy-out semantics.

Each parameter may be labeled with a direction:

- ```in``` parameters are read-only. It is an error to use an ```in```
  parameter on the left-hand side of an assignment or to
  pass it to a callee as a non-```in``` argument. ```in``` parameters
  are initialized by copying the value of the corresponding
  argument when the invocation is executed.

- ```out``` parameters are uninitialized (parameters of type ```header```
  or ```header_union``` are set to "invalid") and are treated as l-values
  (See Section [#sec-lvalues]) within the body of the method or function.
  An arguments passed as an ```out```
  parameter must be an l-value; after the execution of the
  call, the value of the parameter is copied to the corresponding storage location
  for that l-value.
- ```inout``` parameters are both ```in``` and ```out```. An argument passed as
    an ```inout``` parameter must be an l-value.
- No direction indicates that value of parameter is either:
	- a compile-time known value
	- an action parameter that can only be set by the control plane
	- an action parameter that can be set directly by another calling
      action; in this case it behaves like an ```in``` parameter

Arguments are evaluated from left to right prior to the invocation of the
function itself. The order of evaluation is important when the
expression supplied for an argument can have side-effects. Consider
the following example:

~ Begin P4Example
extern void f(inout bit x, in bit y);
extern bit g(inout bit z);
bit a;
f(a, g(a));
~ End P4Example

Note that the evaluation of ```g``` may mutate its argument ```a```, so the
compiler has to ensure that the value passed to ```f``` for its first
parameter is not changed by the evaluation of the second argument. The
semantics for evaluating a function call is given by the following
algorithm (implementations can be different as long as they provide
the same result):

1.	Arguments are evaluated from left to right as they appear in the
      function call expression.
2.	For each ```out``` and ```inout``` argument the corresponding
      l-value is saved (so it cannot be changed by the evaluation of
      the following arguments). This is important if the argument
      contains indexing operations into a header stack.
3.	The value of each argument is saved into a temporary.
4.	The function is invoked with the temporaries as arguments. We are
      guaranteed that the temporaries that are passed as arguments are
      never aliased to each other, so this "generated" function call
      can be implemented using call-by-reference if supported by the
      architecture.
5.	On function return, the temporaries that correspond to ```out```
      or ```inout``` arguments are copied in order from left to right
      into the l-values saved in step 2.

According to this algorithm, the previous function call is equivalent
to the following sequence of statements:

~ Begin P4Example
bit tmp1 = a;     // evaluate a; save result
bit tmp2 = g(a);  // evaluate g(a); save result; modifies a
f(tmp1, tmp2);    // evaluate f; modifies tmp1
a = tmp1;         // copy inout result back into a
~ End P4Example

To see why Step 2 in the above algorithm is important, consider the following
example:

~ Begin P4Example
header H { bit z; }
H[2] s;
f(s[a].z, g(a));
~ End P4Example

The evaluation of this call is equivalent to the following sequence of
statements:

~ Begin P4Example
bit tmp1 = a;          // save the value of a
bit tmp2 = s[tmp1].z;  // evaluate first argument
bit tmp3 = g(a);       // evaluate second argument; modifies a
f(tmp2, tmp3);         // evaluate f; modifies tmp2
s[tmp1].z = tmp2;      // copy inout result back; dest is not s[a].z
~ End P4Example

When used as arguments, ```extern``` objects can only be passed as
directionless parameters---e.g., see the packet argument in the
very simple switch example.

### Justification

The main reason for using copy-in/copy-out semantics (instead of the more common
call-by-reference semantics) is for controlling the side-effects of ```extern```
functions and methods. ```extern``` methods and functions
are the main mechanism by which a P4 program communicates with its
environment. With copy-in/copy-out semantics ```extern``` functions
cannot hold references to P4 program objects; this enables the
compiler to limit the side-effects that ```extern``` functions may
have on the P4 program both in space (they can only affect ```out```
parameters) and in time (side-effects can only occur at function call
time).

In general, ```extern``` functions are arbitrarily powerful: they can store
information in global storage, spawn separate threads, "collude" with
each other to share information --- but they cannot access any
variable in a P4 program. With copy-in/copy-out semantics the compiler
can still reason about P4 programs that invoke ```extern```
functions.

There are additional benefits of using copy-in copy-out semantics:

- It enables P4 to be compiled for architectures that do not support
  references (e.g., where all data is allocated to named
  registers. Such architectures may require indices into header stacks that appear
  in a program to be compile-time known values.)
- It simplifies some compiler analyses, since function parameters can
  never alias to each other within the function body.

~ Begin P4Grammar
parameterList
    : /* empty */
    | nonEmptyParameterList
    ;

nonEmptyParameterList
    : parameter
    | nonEmptyParameterList ',' parameter
    ;

parameter
    : optAnnotations direction typeRef name
    ;

direction
    : IN
    | OUT
    | INOUT
    | /* empty */
    ;
~ End P4Grammar

Following is a summary of the constraints imposed by the parameter
directions:

- When used as arguments, extern objects can only be passed as
  directionless parameters.
- All constructor parameters are evaluated at compilation-time, and in
  consequence they must all be directionless (they cannot be `in`,
  `out`, or `inout`); this applies to `package`, `control`, `parser`,
  and `extern` objects. Values for these parameters must be specified
  at compile-time, and must evaluate to compile-time known values.
- For actions all directionless parameters must be at the end of the
  parameter list.  When an action appears in a `table`'s `actions`
  list, only the parameters with a direction must be bound.
- Actions can also be explicitly invoked using function call syntax,
  either from a control block or from another action. In this case,
  values for all action parameters must be supplied explicitly,
  including values for the directionless parameters. The directionless
  parameters in this case behave like `in` parameters.

## Name resolution { #sec-name-resolution }

P4 objects that introduce namespaces are organized in a hierarchical
fashion. There is a top-level unnamed namespace containing all
top-level declarations.

Identifiers prefixed with a dot are always resolved in the top-level
namespace.

~ Begin P4Example
const bit<32> x = 2;
control c() {
   int<32> x = 0;
   apply {
       x = x + (int<32>).x;  // x is the int<32> local variable,
                             // .x is the top-level bit<32> variable
   }
}
~ End P4Example

References to resolve an identifier are attempted inside-out, starting
with the current scope and proceeding to all lexically enclosing
scopes. The compiler may provide a warning if multiple resolutions are
possible for the same name (name shadowing).

~ Begin P4Example
const bit<4> x = 1;
control p() {
    const bit<8> x = 8;    // x declaration shadows global x
    const bit<4> y = .x;   // reference to top-level x
    const bit<8> z = x;    // reference to p's local x
    apply {}
}
~ End P4Example

## Visibility { #sec-name-visibility }

Identifiers defined in the top-level namespace are globally
visible. Declarations within a ```parser``` or ```control``` are
private and cannot be referred to from outside of the enclosing
```parser``` or ```control```.

# P4 data types { #sec-p4-type }

P4~16~ is a statically-typed language. Programs that do not pass
the type checker are considered invalid and rejected by the
compiler. P4 provides a number of base types as well as type operators that
construct derived types. Some values can be converted to a different type using
casts. However, to make user intents clear, implicit casts are only allowed in
a few circumstances and the range of casts available is intentionally
restricted.

## Base types { #sec-base-types }

P4 supports the following built-in base types:

- The ```void``` type, which has no values and can be used only in a few
  restricted circumstances.
- The ```error``` type, which is used to convey errors in a
  target-independent, compiler-managed way.
- The ```match_kind``` type, which is used for describing the implementation of
  table lookups,
- ```bool```, which represents boolean values
- Bit-strings of fixed width, denoted by ```bit<>```
- Fixed-width signed integers represented using two's complement ```int<>```
- Bit-strings of dynamically-computed width with a fixed maximum width ```varbit<>```

~ Begin P4Grammar
baseType
    : BOOL
    | ERROR
    | BIT
    | BIT '<' INTEGER '>'
    | INT '<' INTEGER '>'
    | VARBIT '<' INTEGER '>'
    ;
~ End P4Grammar

### The void type

The void type is written ```void```. It contains no values. It is
not included in the production rule ```baseType``` as it can only appear in few
restricted places in P4 programs.

### The error type

The error type contains opaque values that can be used to signal
errors. It is written as ```error```. New constants of the error type
are defined with the syntax:

~ Begin P4Grammar
errorDeclaration
    : ERROR '{' identifierList '}'
    ;
~ End P4Grammar

All ```error``` constants are inserted into the ```error```
namespace, irrespective of the place where an error is
defined. ```error``` is similar to an enumeration (```enum```)
type in other languages. A program can contain multiple ```error``` declarations, which
the compiler will merge together. It is an error to declare the same
identifier multiple times. Expressions of type ```error``` are
described in Section [#sec-error-exprs].

For example, the following declaration creates two constants of ```error```
type (these errors are declared in the P4 core library):

~ Begin P4Example
error { ParseError, PacketTooShort }
~ End P4Example

The underlying representation of errors is target-dependent.

### The match kind type { #sec-match-kind-type }

The ```match_kind``` type is very similar to the ```error``` type and
is used to declare a set of names that may be
used in a table's key property (described in Section
[#sec-table-props]).
All identifiers are inserted into the
top-level namespace.
It is an error to declare the same ```match_kind```
identifier multiple times.

~ Begin P4Grammar
matchKindDeclaration
    : MATCH_KIND '{' identifierList '}'
    ;
~ End P4Grammar

The P4 core library contains the following match_kind declaration:

~ Begin P4Example
match_kind {
   exact,
   ternary,
   lpm
}
~ End P4Example

Architectures may support additional ```match_kind```s. The
declaration of new ```match_kind```s can only occur within model
description files; P4 programmers cannot declare new match kinds.

### The boolean type { #sec-bool-type }

The boolean type ```bool``` contains just two values, ```false``` and ```true```.
Boolean values are not integers or bit-strings.

### Strings { #sec-strings }

P4 offers no support for string processing. The only strings that can
appear in a P4 program are constant string literals, described in
Section [#sec-string-literals]. String literals can only be used in
annotations (described in Section [#sec-annotations]). For example,
the following annotation indicates that a specific name should be used
for a table when generating the control-plane API:

~ Begin P4Example
@name("acl") table t1 { ...}
~ End P4Example

### Integers (signed and unsigned) { #sec-integers }

P4 supports arbitrary-size integer values. The typing rules for the
integer types are chosen according to the following principles:

- **Inspired by C**: Typing of integers is modeled after the
  well-defined parts of C, expanded to cope with arbitrary fixed-width
  integers. In particular, the type of the result of an expression
  only depends on the expression operands, and not on how the result
  of the expression is consumed.
- **No undefined behaviors**: P4 attempts to avoid many of C's
  behaviors, which include the size of an integer (int), the results produced
  on overflow, and the results produced for some input combinations
  (e.g., shifts with negative amounts, overflows on signed numbers,
  etc.). P4 computations on integer types have no
  undefined behaviors.
- **Least surprise**: The P4 typing rules are chosen to behave as
  closely as possible to traditional well-behaved C programs.
- **Forbid rather than surprise**: Rather than provide surprising or
  undefined results (e.g., in C comparisons between signed and
  unsigned integers), we have chosen to forbid expressions with
  ambiguous interpretations. For example, P4 does not allow binary
  operations that combine signed and unsigned integers.

The priority of arithmetic operations is identical to C---e.g.,
multiplication binds tighter than addition.

#### Portability

No P4 target can support all possible types and operations. For
example, the type ```bit<23132312>``` is legal in P4, but
it is highly unlikely to be supported on any target in practice. Hence,
each target can impose restrictions on the types it can support. Such
restrictions may include:

- The maximum width supported
- Alignment and padding constraints (e.g., arithmetic may only be
  supported on widths which are an integral number of bytes).
- Constraints on some operands (e.g., some architectures may only
  support multiplications with small constants, or shifts with small
  values).

The documentation supplied with each target should clearly specify such restrictions, and
target-specific compilers should provide clear error messages when
such restrictions are encountered. An architecture may reject a
well-typed P4 program and still be conformant to the P4 spec. However,
if an architecture accepts a P4 program as valid, the runtime program
behavior should match this specification.

#### Unsigned integers (bit-strings)

An unsigned integer (which we also call a "bit-string") has an
arbitrary width, expressed in bits. A bit-string of width ```W``` is
declared as: ```bit<W>```. ```W``` must be a compile-time known value
(see Section [#sec-ct-constants]) that evaluates to a positive integer
greater or equal to 0.

Bits within a bit-string are numbered from ```0``` to ```W-1```. Bit ```0```
is the least significant, and bit ```W-1``` is the most significant.

For example, the type ```bit<128>``` denotes the type of bit-string
values with 128 bits numbered from 0 to 127, where bit 127 is the most
significant.

The type ```bit``` is a shorthand for ```bit<1>```.

P4 architectures may impose additional constraints on bit types: for
example, they may limit the maximum size, or they may only support
some arithmetic operations on certain sizes (e.g., 16-, 32-, and 64-
bit values).

All operations that can be performed on unsigned integers are
described in Section [#sec-bit-ops].

#### Signed Integers

Signed integers are represented using 2's complement. An integer with ```W```
bits is declared as: ```int<W>```. ```W``` must be a compile-time known value
evaluating to a positive integer greater than 1.

Bits within an integer are numbered from ```0``` to ```W-1```. Bit ```0```
is the least significant, and bit ```W-1``` is the sign bit.

For example, the type ```int<64>``` describes the type of integers
represented using exactly 64 bits with bits numbered from 0 to 63,
where bit 63 is the most significant (sign) bit.

P4 architectures may impose additional constraints on signed types:
for example, they may limit the maximum size, or they may only support
some arithmetic operations on certain sizes (e.g., 16-, 32-, and 64-
bit values).

All operations that can be performed on signed integers are described
in Section [#sec-int-ops].

#### Dynamically-sized bit-strings

Some network protocols use fields whose size is only known at runtime
(e.g., IPv4 options). To support restricted manipulations of such
values, P4 provides a special bit-string type whose size is set at
runtime, called a ```varbit```.

The type ```varbit<W>``` denotes a bit-string with a width of at most ```W```
bits, where ```W``` must be a positive integer that is a compile-time
known value. For example, the type ```varbit<120>``` denotes the type
of bit-string values that may have between 0 and 120 bits. Most
operations that are applicable to fixed-size bit-strings (unsigned
numbers) *cannot* be performed on dynamically sized bit-strings.

P4 architectures may impose additional constraints on varbit types:
for example, they may limit the maximum size, or they may require ```varbit```
values to always contain an integer number of bytes at runtime.

All operations that can be performed on varbits are described in
Section [#sec-varbit-string].

#### Infinite-precision integers

The infinite-precision data type describes integers with an unlimited
precision. This type is written as ```int```.

This type is reserved for integer literals and expressions that
involve only literals. No P4 runtime value can have an ```int```
type; at compile time the compiler will convert all int values that
have a runtime component to fixed-width types, according to the rules
described below.

All operations that can be performed on infinite-precision integers
are described in Section [#sec-varint-ops].

#### Integer literal types

The types of integer literals (constants) are as follows:

- A simple integer constant has type ```int```.
- A positive integer prefixed with an integer width ```N``` and the
  character ```w``` has type ```bit<N>```.
- An integer prefixed with an integer width ```N``` and the character ```s```
  has type ```int<N>```.

The table below shows several examples of integer literals and their
types. For additional examples of literals see Section
[#sec-literals].

+--------:+--------------------+
| Literal | Interpretation |
|----------|--------------------|
| ```10```    | Type is ```int```, value is 10 |
| ```8w10```  | Type is ```bit<8>```, value is 10 |
| ```8s10```  | Type is ```int<10>```, value is 10 |
| ```2s3```   | Type is ```int<2>```, value is -1 (last 2 bits), overflow warning |
| ```1w10```  | Type is ```bit<1>```, value is 0 (last bit), overflow warning |
| ```1s10```  | Error: 1-bit signed type is illegal |
|----------|--------------------|

## Derived types { #sec-derived-types }

P4 provides a number of type constructors that can be used to derive
additional types including:

- ```enum```
- ```header```
- header stacks
- header unions
- ```struct```
- ```tuple```
- type specialization
- ```extern```
- ```parser```
- ```control```
- ```package```

The types ```header```, ```header_union```, ```enum```, ```struct```, ```extern```, ```parser```, ```control```,
and ```package``` can only be used in type declarations, where they
introduce a new name for the type. The type can subsequently be
referred to using this identifier.

Other types cannot be declared, but are synthesized by the compiler
internally to represent the type of certain language constructs. These
types are described in Section [#sec-synth-types]: set types and
function types. For example, the programmer cannot declare a variable
with type "set", but she can write an expression whose value evaluates
to a ```set``` type. These types are used during type-checking.

~ Begin P4Grammar
typeDeclaration
    : derivedTypeDeclaration
    | typedefDeclaration
    | parserTypeDeclaration ';'
    | controlTypeDeclaration ';'
    | packageTypeDeclaration ';'
    ;

derivedTypeDeclaration
    : headerTypeDeclaration
    | headerUnionDeclaration
    | structTypeDeclaration
    | enumDeclaration
    ;

typeRef
    : baseType
    | typeName
    | specializedType
    | headerStackType
    | tupleType
    ;

prefixedType
    : TYPE
    | dotPrefix TYPE
    ;

typeName
    : prefixedType
    ;
~ End P4Grammar

### Enumeration types { #sec-enum-types }

An enumeration type is defined using the following syntax:

~ Begin P4Grammar
enumDeclaration
    : optAnnotations ENUM name '{' identifierList '}'
    ;

identifierList
    : name
    | identifierList ',' name
    ;
~ End P4Grammar

For example, the declaration

~ Begin P4Example
enum Suits { Clubs, Diamonds, Hearths, Spades }
~ End P4Example

introduces a new enumeration type, which contains four
constants---e.g., ```Suits.Clubs```. An ```enum``` declaration
introduces a new identifier in the current scope for naming the
created type. The underlying representation of such values is not
specified, so their "size" in bits is not specified (it is
target-specific).

Annotations, represented by the non-terminal ```optAnnotations```, are
described in Section [#sec-annotations].

Operations on ```enum``` values are described in Section
[#sec-enum-exprs].

### Header types { #sec-header-types }

The declaration of a ```header``` type is given by the following
syntax:

~ Begin P4Grammar
headerTypeDeclaration
    : optAnnotations HEADER name '{' structFieldList '}'
    ;

structFieldList
    : /* empty */
    | structFieldList structField
    ;

structField
    : optAnnotations typeRef name ';'
    ;
~ End P4Grammar

where each ```typeRef``` is restricted to a bit-string type (fixed or
variable) or an integer type. This declaration introduces a new
identifier in the current scope; the type can be referred to using
this identifier. A header is similar to a ```struct``` in C,
containing all the specified fields. However, in addition, a header also
contains a hidden boolean "validity" field. When the "validity" bit is ```true```
we say that the "header is valid". When a header is created
its "validity" bit is automatically set to ```false```. The "validity"
bit can be manipulated by using the header methods ```isValid()```, ```setValid()```,
and ```setInvalid()```, as described in Section [#sec-ops-on-hdrs].

Header types may be empty:

~ Begin P4Example
header Empty_h { }
~ End P4Example

Note that an empty header still contains a validity bit.

Headers that do not contain any ```varbit``` field are "fixed
size." Headers containing ```varbit``` fields have "variable
size." The size (in bits) of a fixed-size header is a constant, and it
is simply the sum of the sizes of all component fields (without
counting the validity bit). There is no padding or alignment of the
header fields. Architectures may impose additional constraints on
header types---e.g., restricting headers to sizes that are an integer
number of bytes.

For example, the following declaration describes a typical Ethernet
header:

~ Begin P4Example
header Ethernet_h {
   bit<48> dstAddr;
   bit<48> srcAddr;
   bit<16> etherType;
}
~ End P4Example

The following variable declaration uses the newly introduced type ```Ethernet_h```:

~ Begin P4Example
Ethernet_h ethernetHeader;
~ End P4Example

P4's parser language provides an ```extract``` method that can be used to
"fill in" the fields of a header from a network packet, as described
in Section [#sec-packet-data-extraction]. The successful execution of
an ```extract``` operation also sets the validity bit of the extracted
header to ```true```.

Here is an example of an IPv4 header with variable-sized options:

~ Begin P4Example
header IPv4_h {
   bit<4>       version;
   bit<4>       ihl;
   bit<8>       diffserv;
   bit<16>      totalLen;
   bit<16>      identification;
   bit<3>       flags;
   bit<13>      fragOffset;
   bit<8>       ttl;
   bit<8>       protocol;
   bit<16>      hdrChecksum;
   bit<32>      srcAddr;
   bit<32>      dstAddr;
   varbit<320>  options;
}
~ End P4Example

As discussed in Section [#sec-list-exprs], headers that contain
variable-length fields may need to be parsed in multiple steps by
being broken into multiple headers.

### Header stacks { #sec-header-stacks }

A header stack represents an array of headers. A header stack type is
defined as:

~ Begin P4Grammar
headerStackType
    : typeName '[' expression ']'
    ;
~ End P4Grammar

where ```typeName``` is the name of a header type. For a header stack ```hs[n]```,
the term ```n``` is the maximum defined size, and must be
a positive integer that is a compile-time known value. Nested header
stacks are not supported. At runtime a stack contains ```n``` values
with type ```typeName```, only some of which may be valid. Expressions
on header stacks are discussed in Section [#sec-expr-hs].

For example, the following declarations,

~ Begin P4Example
header Mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit     bos;
    bit<8>  ttl;
}
Mpls_h[10] mpls;
~ End P4Example

introduce a header stack called ```mpls``` containing 10 entries, each
of type ```Mpls_h```.

### Header unions {#sec-header-unions}

A header union represents an alternative between different
headers. Header unions can be used to represent "options" in protocols
like TCP and IP. They also provide hints to P4 compilers that only one
alternative will be present, allowing it to conserve storage resources.

A header union is defined as:

~ Begin P4Grammar
headerUnionDeclaration
    : optAnnotations HEADER_UNION name
      '{' structFieldList '}'
    ;
~ End P4Grammar

This declaration introduces a new type with the specified name in the
local scope. Each element of the list of fields used to declare a
header union must be a header type. However, the empty list of fields
is legal.

As an example, the type `Ip_h` below represents the union of an IPv4
and IPv6 headers:

~ Begin P4Example
header_union IP_h {
  IPv4_h v4;
  IPv6_h v6;
}
~ End P4Example

### Struct types { #sec-struct-types }

P4 ```struct``` types are defined with the following syntax:

~ Begin P4Grammar
structTypeDeclaration
    : optAnnotations STRUCT name '{' structFieldList '}'
    ;
~ End P4Grammar

This declaration introduces a new type with the specified name in the
local scope. An empty struct is legal. For example, the structure ```Parsed_headers```
below contains the headers recognized by a simple parser:

~ Begin P4Example
header Tcp_h { ... }
header Udp_h { ... }
struct Parsed_headers {
    Ethernet_h ethernet;
    Ip_h       ip;
    Tcp_h      tcp;
    Udp_h      udp;
}
~ End P4Example

The table below lists all types that may appear as members of headers,
header unions, structs, and tuples.  Note that ```int``` means an
infinite-precision integer, without a width specified.

|-----|-----|-----|
|                    | Container type |||
|                    |           | header_ |                 |
| Element type       | header    | union   | struct or tuple |
+:-------------------+:----------+:--------+:----------------+
| ```bit<W>```       | allowed   | error   |  allowed        |
| ```int<W>```       | allowed   | error   |  allowed        |
| ```varbit<W>```    | allowed   | error   |  allowed        |
| ```int```          | error     | error   |  error          |
| ```void```         | error     | error   |  error          |
| ```error```        | error     | error   |  allowed        |
| ```match_kind```   | error     | error   |  error          |
| ```bool```         | error     | error   |  allowed        |
| ```enum```         | error     | error   |  allowed        |
| ```header```       | error     | allowed |  allowed        |
| header stack       | error     | error   |  allowed        |
| ```header_union``` | error     | error   |  allowed        |
| ```struct```       | error     | error   |  allowed        |
| ```tuple```        | error     | error   |  allowed        |
|-----|-----|-----|

The rationale for the restrictions is as follows. The type ```int<W>```
has easily-determined storage requirements, unlike
infinite precision ```int```s.  ```match_kind``` values are not useful
to store in a variable, as they are only used to specify how to match
fields in table search keys, which are all declared at compile time. ```void```
is not useful as part of another data structure.  Headers must have
precisely defined formats as sequences of bits in order for them to be
parsed or deparsed.

### Tuple types { #sec-tuple-types }

A tuple is similar to a ```struct```, in that it holds multiple
values. Unlike a ```struct``` type, tuples have no named fields. The
type of tuples with n component types ```T1```,...,```Tn``` is written
as ```tuple<T1,...,Tn>```.

~ Begin P4Grammar
tupleType
    : TUPLE '<' typeArgumentList '>'
    ;
~ End P4Grammar

Operations that manipulate tuple types are described in Sections
[#sec-list-exprs] and [#sec-set-exprs]. Tuple types can be converted
to structure types that have the same number of fields when each field
has a type that is identical to the corresponding tuple element.

~ Begin P4Example
struct S { bit<32> a; bit<16> b; }
tuple<bit<32>, bit<16>> x;
x = { 32w25, 16w35 };
S y = x;
~ End P4Example

### Synthesized data types { #sec-synth-types }

For the purposes of type-checking the P4 compiler can synthesize some
type representations which cannot be directly expressed by
users. These are described in this section: set types and function
types.

#### Set types

The type ```set<T>``` describes _sets_ of values of type ```T```. Set
types can only appear in restricted contexts in P4 programs. For
example, the range expression ```8w5 .. 8w8``` describes a set
containing the 8-bit numbers 5, 6, 7, and 8, so its type is ```set<bit<8>>;```.
This expression can be used as a label in a ```select``` expression
(see Section [#sec-select]), matching any value in this range. Set
types cannot be named or declared by P4 programmers, they are only
synthesized by the compiler internally and used for
type-checking. Expressions with set types are described in Section
[#sec-set-exprs].

#### Function types { #sec-function-type }

[]{tex-cmd: "\indent"}
Currently function types cannot be created explicitly in P4 programs;
they are created by the P4 compiler internally to represent the types
of functions, procedures, and methods during
type-checking. We also call the type of a function its
signature. Libraries can contain extern function declarations.

For example, the following declaration:

~ Begin P4Example
extern void random(in bit<5> logRange, out bit<32> value);
~ End P4Example

describes an object ```random``` which has a function type,
representing the following information:

- the result type is ```void```
- the function has two inputs
- first input has direction ```in```, type ```bit<5>```, and name `logRange`
- second input has direction ```out```, type ```bit<32>```, and name ```value```

### Extern types { #sec_extern }

[]{tex-cmd: "\indent"}
P4 supports extern object declarations and extern function declarations using the following syntax.

~ Begin P4Grammar
externDeclaration
    : optAnnotations EXTERN nonTypeName optTypeParameters '{' methodPrototypes '}'
    | optAnnotations EXTERN functionPrototype ';'
    ;
~ End P4Grammar

#### Extern functions

[]{tex-cmd: "\indent"}
An extern function declaration describes the name and type signature of the function,
but not its implementation.

~ Begin P4Grammar
functionPrototype
    : typeOrVoid name optTypeParameters '(' parameterList ')'
    ;
~ End P4Grammar

For an example of an ```extern``` function declaration, see Section
[#sec-function-type].

#### Extern objects

[]{tex-cmd: "\indent"}
An extern object declaration declares an object and all methods that
can be invoked to perform computations and to alter the state of the
object. Extern object declarations can also optionally declare
constructor methods; these must have the same name as the enclosing ```extern```
type, no type parameters, and no return type.  Extern declarations may
only appear as allowed by the architecture model and may be specific
to a target.

~ Begin P4Grammar
methodPrototypes
    : /* empty */
    | methodPrototypes methodPrototype
    ;

methodPrototype
    : functionPrototype ';'
    | TYPE '(' parameterList ')' ';' //constructor
    ;

typeOrVoid
    : typeRef
    | VOID
    | nonTypeName     // may be a type variable
    ;

optTypeParameters
    : /* empty */
    | '<' typeParameterList '>'
    ;

typeParameterList
    : nonTypeName
    | typeParameterList ',' nonTypeName
    ;
~ End P4Grammar

For example, the P4 core library introduces two extern objects ```packet_in```
and ```packet_out``` used for manipulating packets
(see Sections [#sec-packet-data-extraction] and [#sec-deparse]). Here
is an example showing how the methods of these objects can be invoked
on a packet:

~ Begin P4Example
extern packet_out {
    void emit<T>(in T hdr);
}
control d(packet_out b, in Hdr h) {
    apply {
        b.emit(h.ipv4);       // write ipv4 header into output packet
    }                         // by calling emit method
}
~ End P4Example

Functions and methods are the only P4 constructs that support
overloading: there can exist multiple methods with the same name in
the same scope. Even so, two functions (or methods of an ```extern```
object) can have the same name only if they have a different number of
parameters.

### Type specialization { #sec-type-spec }

A generic type may be specialized by specifying arguments for its type
variables. In cases where the compiler can infer type arguments type
specialization is not necessary. When a type is specialized all its
type variables must be bound.

~ Begin P4Grammar
specializedType
    : prefixedType '<' typeArgumentList '>'
    ;
~ End P4Grammar

For example, the following extern declaration describes a generic
block of registers, where the type of the elements stored in each
register is an arbitrary ```T```.

~ Begin P4Example
extern Register<T> {
    Register(bit<32> size);
    T read(bit<32> index);
    void write(bit<32> index, T value);
}
~ End P4Example

The type ```T``` has to be specified when instantiating a set of
registers, by specializing the Register type:

~ Begin P4Example
Register<bit<32>>(128) registerBank;
~ End P4Example

The instantiation of ```registerBank``` is made using the ```Register```
type specialized with the ```bit<32>``` bound to the ```T``` type argument.

### Parser and control blocks types { #sec-parser-control-types }

Parsers and control blocks types are similar to function types: they
describe the signature of parsers and control blocks. Such functions
have no return values. Declarations of parsers and control block types
in architectures may be generic
(i.e., have type parameters).

The types ```parser```, ```control```, and ```package``` cannot be
used as the types of arguments for methods, parsers, controls, tables,
actions. They _can_ be used as types for the arguments passed to
constructors (see Section [#sec-parametrization]).

#### Parser type declarations

A parser type declaration describes the signature of a parser. A
parser should have at least one argument of type ```packet_in```,
representing the received packet that is processed.

~ Begin P4Grammar
parserTypeDeclaration
    : optAnnotations PARSER name optTypeParameters
     '(' parameterList ')'
    ;
~ End P4Grammar

For example, the following is a type declaration of a parser type
named ```P``` that is parameterized on a type variable ```H```. The parser
that receives as input a ```packet_in``` value ```b``` and produces
two values:
- A value of type ```H```, and
- A value with a predefined type ```Counters```.

~ Begin P4Example
struct Counters { ... }
parser P<H>(packet_in b,
             out H packetHeaders,
             out Counters counters);
~ End P4Example

#### Control type declarations

A control type declaration describes the signature of a control block.

~ Begin P4Grammar
controlTypeDeclaration
    : optAnnotations CONTROL name optTypeParameters
      '(' parameterList ')'
    ;
~ End P4Grammar

Control type declarations are similar to parser type
declarations.

### Package types { #sec-pkg-types }

A package type describes the signature of a package.

~ Begin P4Grammar
packageTypeDeclaration
    : optAnnotations PACKAGE name optTypeParameters
      '(' parameterList ')'
    ;
~ End P4Grammar

All parameters of a package are evaluated at compilation-time, and in
consequence they must all be directionless (they cannot be ```in```, ```out```,
or ```inout```). Otherwise package types are very similar to
parser type declarations. Packages can only be instantiated; there are
no runtime behaviors associated with them.

### Don't care types { #sec-dont-care-types }

A don't care (underscore, "`_`") can be used in some circumstances as
a type.  It should be only used in a position where one could write a
bound type variable.  The
underscore can be used to reduce code complexity---when it is not
important what the type variable binds to (during type unification the
don't care type can unify with any other type).  An example is given
Section [#sec-arch-desc-example].

## typedef { #sec-typedef }

A ```typedef``` declaration can be used to give an alternative name to
a type.

~ Begin P4Grammar
typedefDeclaration
    : TYPEDEF typeRef name ';'
    | TYPEDEF derivedTypeDeclaration name ';'
    | annotations TYPEDEF typeRef name ';'
    | annotations TYPEDEF derivedTypeDeclaration name ';'
    ;
typedef bit<32> u32;
typedef struct Point { int<32> x; int<32> y; } Pt;
typedef Empty_h[32] HeaderStack;
~ End P4Grammar

The two types are treated as synonyms, and all operations that can be
executed using the original type can be also executed using the newly
created type.

# Expressions { #sec-exprs }

This section describes all computations that can be performed in P4,
grouped by the type of the values than can be processed.

The grammar for general expressions is given by:

~ Begin P4Grammar
expression
    : INTEGER
    | TRUE
    | FALSE
    | STRING_LITERAL
    | nonTypeName
    | '.' nonTypeName
    | expression '[' expression ']'
    | expression '[' expression ':' expression ']'
    | '{' expressionList '}'
    | '(' expression ')'
    | '!' expression
    | '~' expression
    | '-' expression
    | '+' expression
    | typeName '.' member
    | ERROR '.' member
    | expression '.' member
    | expression '*' expression
    | expression '/' expression
    | expression '%' expression
    | expression '+' expression
    | expression '-' expression
    | expression SHL expression      // SHL is <<
    | expression '>''>' expression   // check that >> are contiguous
    | expression LE expression       // LE is <=
    | expression GE expression
    | expression '<' expression
    | expression '>' expression
    | expression NE expression       // NE is !=
    | expression EQ expression       // EQ is ==
    | expression '&' expression
    | expression '^' expression
    | expression '|' expression
    | expression PP expression       // PP is ++
    | expression AND expression      // AND is &&
    | expression OR expression       // OR is ||
    | expression '?' expression ':' expression
    | expression '<' typeArgumentList '>' '(' argumentList ')'
    | expression '(' argumentList ')'
    | typeRef '(' argumentList ')'
    | '(' typeRef ')' expression
    ;

expressionList
    : expression
    | expressionList ',' expression
    ;

member
    : name
    ;

argumentList
    : /* empty */
    | nonEmptyArgList
    ;

nonEmptyArgList
    : argument
    | nonEmptyArgList ',' argument
    ;

argument
    : expression
    ;

typeArg
    : DONTCARE
    | typeRef
    ;

typeArgumentList
    : typeArg
    | typeArgumentList ',' typeArg
    ;

~ End P4Grammar

See also the complete P4 grammar in Appendix [#sec-grammar].

An additional semantic check is required for the right shift to check
that there is no space between the two consecutive greater-than signs ```>>```.
This rule is required to allow parsing for both the right
shift operators and specialized types, such as in ```function<bit<32>>```.

This grammar does not indicate the precedence of the various
operators. The precedence follows exactly the C precedence
rules. Concatenation (```++```) has the same precedence as infix
addition. Bit-slicing ```a[m:l]``` has the same precedence as array
indexing (```a[i]```).

In addition to these expressions, ```select``` expressions (described
in Section [#sec-select]) may be used only in parsers.

## Expression evaluation order { #sec-expr-eval-order }

Given a complex expression, the order in which sub-expressions are
evaluated can be important if these sub-expressions can produce
side-effects. P4 expressions are evaluated as follows:

- Boolean operators ```&&``` and ```||``` are evaluated short-circuit:
  the second operand is only evaluated if necessary.
- The conditional operator ```?:``` evaluates its first argument, and
  based on its values it evaluates the second or the third.
- All other expressions are evaluated left-to-right as they appear in
  the source program.
- Function and method calls are evaluated as described in Section
  [#sec-calling-convention].

## Expressions on error values { #sec-error-exprs }

Symbolic names declared by an ```error``` declaration belong to the ```error```
namespace.  The ```error``` type only supports comparisons
for equality and difference.  The result of a comparison is a boolean
value.

For example, the following operation tests for the occurrence of an
error:
~ Begin P4Example
error errorFromParser;
...
if (errorFromParser != error.NoError) { ... }
~ End P4Example

## Expressions on enum values { #sec-enum-exprs }

Symbolic names declared by an ```enum``` do not belong to the
top-level namespace, but to a newly introduced namespace.

~ Begin P4Example
enum X { v1, v2, v3 }
X.v1  // reference to v1
v1    // error - v1 is not in the top-level namespace
~ End P4Example

An ```enum``` value can only be compared for equality/difference using ```== and !=```. ```enum```
values cannot be cast to or from any other types.

When ```enum``` values appear in the control-plane API the compiler
back-end has to choose a suitable serialization data type and
representation.

## Expressions on boolean values { #sec-bool-exprs }

The following operations are provided on boolean values:
- And, designated by ```&&```
- Or designated by ```||```
- Negation, designated by ```!```
- Equality tests (```==``` and ```!=```)

Operator precedence is similar to C. Operator evaluation is
short-circuit.

There are no implicit casts from bit-strings to booleans or
vice-versa. As a consequence, a C program fragment such as:

~ Begin P4Example
if (x) ...
~ End P4Example

(for x an integer base type) must be written in P4 as:

~ Begin P4Example
if (x != 0) ...
~ End P4Example

(see also the discussion on infinite-precision types and implicit
casts in Section [#sec-implicit-casts] for how the 0 in this
expression is evaluated).

### The conditional operator

The ```?:``` expression behaves as in C, e.g.:

~ Begin P4Example
(x == 0) ? e0 : e1;
~ End P4Example

The first argument is boolean, and the second and third arguments must
have the same type. The second and third arguments cannot be both
infinite precision integers unless the condition itself can be
evaluated at compilation time (this restriction exists in order to
allow the width of the result of the conditional operation to be
inferred; the type of the result cannot be ```int```, which is
reserved for integer literals). The conditional operator evaluation is
short-circuit: only the selected alternative is evaluated.

## Bit-string (unsigned integer) operations { #sec-bit-ops }

This section discusses all operations that can be performed on values
with ```bit<W>``` types.

Arithmetic operations "wrap-around", similar to C operations on
unsigned values (i.e., representing a large value on W bits will only
keep the least-significant W bits of the value). There are no
arithmetic exceptions; the runtime result of an arithmetic operation
is defined for all combinations of input arguments.

All binary operations (except shifts) require both operands to have
the same exact type and width; supplying operands with different
widths produces an error at compile time. No implicit casts are
inserted by the compiler to equalize the widths. There are no binary
operations that combine signed and unsigned values (except shifts).
The following operations are provided on Bit-string values:

- Test for equality between bit-strings of the same width, designated
  by ```==```. The result is a boolean value.
- Test for difference between bit-strings of the same width,
  designated by ```!=```. The result is a boolean value.
- Unsigned comparisons ```<,>,<=,>=```. Both operands must have the
  same width; the result is a boolean value.

All the following operations produce bit-string results when applied
to bit-strings. All these operations require both operands to have the
same width.

- Negation, denoted by unary ```-```. Result is computed by
  subtracting the value from 2^W^. The result is always unsigned and
  it has the same width as the input. The semantics is the same as the
  C negation of unsigned numbers.
- Unary plus, denoted by ```+```. Behaves as a no-op.
- Addition, denoted by ```+```.  Associative. Result is computed by
  truncating the result of the addition to the width of the output
  (similar to C).
- Subtraction, denoted by ```-```. Result is unsigned, and has the
  same type as the operands. Result is computed by adding the negation
  of the second operand (similar to C).
- Multiplication ```*```. Result has the same width as the
  operands. P4 targets may impose additional restrictions (e.g., may
  only allow multiplications with powers of two).
- Bitwise "and" between two bit-strings of the same width, designated
  by ```&```
- Bitwise "or" between two bit-strings of the same width, designated
  by ```|```
- Bitwise "complement" of a single bit-string, designated by ```~```
- Bitwise "xor" of two bit-strings of the same width, designated by ```^```

There are also the following operations:

- Concatenation of two bit-strings, resulting in a bit-string whose
  length is the sum of the lengths, designated by the infix operator ```++```.
  The left bit-string provides the most significant bits.
- Extraction of a set of contiguous bits (bit slice), designated by ```[m:l]```,
  where ```m``` and ```l``` must be positive integers
  that are compile-time known values, and ```m >= l```. The result is
  a bit-string of width ```m - l + 1```, including the bits numbered
  from ```l``` (which becomes the LSB of the result) to ```m``` (the
  MSB of the result) from the source operand. The conditions ```0 <= l < W```
  and ```l <= m < W``` are checked statically (where ```W``` is
  the length of the source bit-string). Note that both endpoints of
  the extraction are inclusive. The bounds are required to be
  compile-time known values so that the result width can be computed
  at compile time.
- Slices are l-values: one can assign to a slice: ``` e[m:l] = x ```
  This statement sets bits ```m``` to ```l``` of ```e``` to the
  bit-pattern represented by ```x```, and leaves all other bits of ```e```
  unchanged.
- Logical shift left and right with a runtime known unsigned integer
  value (left operand is unsigned, right operand must be either an
  unsigned number of type ```bit<S>``` or a non-negative constant
  integer), designated by ```<<``` and ```>>```. The result has the
  same type as the left operand. Shifts with an amount greater than
  the width of the input produce a result with all bits zero.

## Operations on fixed-width signed integers { #sec-int-ops }

This section discusses all operations that can be performed on ```int<W>```
types. An ```int<W>``` type is a signed integer with ```W``` bits
represented using 2's complement.

"Underflow" or "overflow" produced by arithmetic cannot be detected:
operations "wrap around", similar to C operations on unsigned values
(i.e., representing a large value on W bits will only keep the
least-significant W bits of the value)

There are no arithmetic exceptions; the runtime result of an
arithmetic operation is defined for all combinations of input
arguments (note that C does not specify the result of overflows on
signed integers).

All binary operations (except shifts) require both operands to have
the same exact type (signedness) and width; supplying operands with
different widths or signedness produces an error at compile time. No
implicit casts are inserted by the compiler to equalize the
types. There are no binary operations that combine signed and unsigned
values (except shifts).

Note that bitwise operations are well-defined, since the
representation is mandated to be 2's complement.

The ```int<W>``` datatype supports the following operations; all
binary operations require both operands to have the exact same
type. The result always has the same width as the left operand.

- Negation, denoted by unary ```-```
- Unary plus, denoted by ```+```. Behaves as a no-op.
- Addition, denoted by ```+```
- Subtraction, denoted by ```-```
- Comparison for equality and inequality ```==,!=``` producing a
  boolean result
- Numeric comparisons ```<,<=,>,>=``` with a boolean result
- Multiplication ```*```. Result has the same width as the
  operands. P4 targets may impose additional restrictions (e.g., may
  only allow multiplications with powers of two).
- Arithmetic shift left and right denoted by ```<<``` and ```>>```.
  Left operand is signed, right operand must be either an
  unsigned number of type ```bit<S>``` or a non-negative constant
  integer. The result has the same type as the left operand. Shifts
  with an amount greater or equal to the width of the input are
  allowed.

### A note about shifts

Shifts (on signed and unsigned values) deserve a special discussion
for the following reasons:

- As in C, right shift behaves differently for signed and unsigned
  values: right shift for signed values is an arithmetic shift.
- Shifting with a negative amount does not have a clear semantics:
  while in C the result is undefined, in P4 the type system makes it
  illegal to shift with a negative amount.
- In C, shifting with an amount larger or equal to the number of bits
  has an undefined result (unlike the P4 definition).
- Finally, shifting may require doing work which is exponential in the
  number of bits of the right-hand-side operand.

Consider the following examples:

~ Begin P4Example
bit<8> x;
bit<16> y;
... y << x ...
... y << 1024 ...
~ End P4Example

Unlike C, P4 gives a precise meaning shifting with an amount larger
than the size of the shifted value.

P4 targets may impose additional restrictions on shift operations:

- Targets may reject shifts by non-constant amounts.
- Targets may reject shifts with large non-constant amounts. For
  example, a target may forbid shifting an 8-bit value by a
  non-constant value wider than 3 bits.

## Operations on arbitrary-precision constant integers { #sec-varint-ops }

The type ```int``` denotes integer values on which computations are
performed with arbitrary precision. Only compile-time known values may
have type ```int``` . They support the following operations:

- Negation, denoted by unary ```-```
- Unary plus, denoted by ```+```. Behaves as a no-op.
- Addition, denoted by ```+```
- Subtraction, denoted by ```-```
- Comparison for equality and inequality ```==,!=``` producing a
  boolean result
- Numeric comparisons ```<,<=,>,>=``` with a boolean result
- Multiplication ```*```
- Integer division between positive values, denoted by ```/```,
  rounded towards 0, as in C
- Modulo between positive values, denoted by ```%```
- Arithmetic shift left and right denoted by ```<<``` and ```>>```.
  Right operand must be a positive number. The result is an ```int```.
  The expression ```a << b``` is equal to $a \times 2^b$ while ```a >> b```
  is equal to $\lfloor{a / 2^b}\rfloor$.

All the operands that participate in an operation must have type ```int```;
binary operations (except shift) cannot combine int values
with fixed-width types. For such expressions the compiler will always
insert an implicit cast; this cast will always convert the ```int```
value to the fixed-width type.

All computations on ```int``` values are carried without information
loss. For example, multiplying two 1024-bit values may produce a
2048-bit value (note that concrete representation of ```int``` values
is not specified). ```int``` values can be cast to ```bit<w>``` and ```int<w>```
values. Casting an ```int``` value to a fixed-width type
will preserve the least-significant bits. If the truncation causes
significant bits to be lost, the compiler should emit a suitable
warning.

Note: bitwise-operations (```|```,```&```,```^```,```~```) are not
defined for ```int``` values. Division and modulo are illegal for
negative values.

## Variable bit-string operations { #sec-varbit-string }

A variable-size bit-string ```varbit``` has a maximum size static
declared width, and also a dynamic width, which must be at most the
static width. Prior to initialization a variable-size bit-string has
an unknown dynamic width.

Variable-length bit-strings support a limited set of operations:

- Parser extraction into a variable-sized bit-string using the
  two-argument ```extract``` method of a ```packet_in``` (see Section
  [#sec-packet-lookahead]). This operation sets the dynamic width of
  the field.
- Assignment to another variable-sized bit-string. The target must
  have the exact same static width. The assignment sets the dynamic
  width on the target to be the same as the source dynamic width.
- The ```emit``` method of a ```packet_out``` interface to insert a
  dynamically-sized bit-string with known dynamic width into a packet
  (see Section [#sec-deparse]).

## Casts { #sec-casts }

P4 supports a very limited range of casts, and casts are only allowed
between base types. Most binary operations require both operands to
have the exact same type. Some type conversions may require multiple
chained casts. While more onerous for the user, this approach has
several benefits:

- It makes user intent unambiguous.
- It makes the conversion cost explicit. Some casts involve
  sign-extensions, and thus require significant computational
  resources.
- It reduces the number of cases that have to be considered in the P4
  specification. Some targets may not support all casts. A cast
  expression is written as in C: ```(typeRef)```

### Explicit casts
Here are all legal casts:

- ```bit<1> <-> bool: 0``` is ```false```, ```1``` is ```true```
- ```int<W> -> bit<W>```: preserves all bits unchanged; negative
  values are reinterpreted as positive values
- ```bit<W> -> int<W>```: preserves all bits unchanged; values with
  the MSB set are reinterpreted as negative values
- ```bit<W> -> bit<X>```: if ```W > X``` this causes truncation, if ```W < X```
  this causes extension with zero bits
- ```int<W> -> int<X>```: if ```W > X``` this causes truncation, if ```W < X```
  this causes extension with the sign bit
- ```int -> bit<W>```: Represents the integer value using two's
  complement on a large enough number of bits and keeps the
  least-significant ```W``` bits; overflow should lead to a warning,
  as will conversion of a negative number
- ```int -> int<W>```: Represents the integer value using two's
  complement on a large enough number of bits and keeps the
  least-significant ```W``` bits; overflow should lead to a warning
- Given a type declaration introduced by ```typedef S T```, values of
  types ```T``` and ```S``` can be cast back and forth if they
  represent base types.

### Implicit casts { sec-implicit-casts }
Unlike C, P4 allows a very limited number of implicit casts. The
reason is that often the implicit casts have a non-trivial semantics,
which is invisible for the programmer.

Implicit casts are allowed in P4 only to convert an ```int`` value to
a fixed-width type.

Most binary operations that take an ```int``` and a fixed-width
operand will insert an implicit cast to convert the ```int``` operand
to the type of the fixed-width operand.

Consider a program with the following values:

~ Begin P4Example
bit<8>  x;
bit<16> y;
int<8>  z;
~ End P4Example

The following expressions are translated by the compiler as follows:

- ```x + 1``` becomes ```x + (bit<8>)1```
- ```z < 0``` becomes ```z < (int<8>)0```
- ```x << 13``` becomes ```0```; overflow warning
- ```x | 0xFFF``` becomes ```x | (bit<8>)0xFFF```; overflow warning

### Illegal arithmetic expressions { #sec-illegal-arith }

Consider a program with the following values:

~ Begin P4Example
bit<8>  x;
bit<16> y;
int<8>  z;
~ End P4Example

The table below shows several expressions which are illegal because
they do not obey the P4 typing rules. For each expression we provide
several ways that the expression could be manually rewritten into a
legal expression. Note that for some expression there are several
legal alternatives, which may produce different results! The compiler
cannot guess the user intent, so the user is required to explicitly
state it.

|-----|-----|-----|
| Expression | Why it is illegal  | Alternatives |
+----------------:+:---------------------+:-----------------+
| ```x + y```             | Different widths | ```(bit<16>)x + y```|
|                         |                           | ```x + (bit<8>)y``` |
| ```x + z```             | Different signs   |  ```(int<8>)x + z``` |
|                         |                           |  ```x + (bit<8>)z ```   |
| ```(int<8>)y```         | Cannot change both sign and width |  ```(int<8>)(bit<8>)y ``` |
|                         |                           |  ```(int<8>)(int<16>)y ``` |
| ```y + z```             | Different widths and signs |  ```(int<8>)(bit<8>)y + z ``` |
|                         |                           |  ```y + (bit<16>)(bit<8>)z ``` |
|                         |                           |  ```(bit<8>)y + (bit<8>)z ``` |
|                         |                           |  ```(int<16>)y + (int<16>)z ``` |
| ```x << z```            | RHS of shift cannot be signed |  ```x << (bit<8>)z ``` |
| ```x < z```             | Different signs |  ```X < (bit<8>)z ``` |
|                         |                           |  ```(int<8>)x < z ``` |
| ```1 << x```            | Width of ```1``` is unknown |  ```32w1 << x ``` |
| ```~1```                | Bitwise operation on int |  ```~32w1 ``` |
| ```5 & -3```            | Bitwise operation on int |  ```32w5 & -3 ``` |
|-----|-----|-----|

## List expressions { #sec-list-exprs }

A list expression is a list of expressions enclosed within curly braces and separated by commas:

~ Begin P4Grammar
expression ...
    | '{' expressionList '}'

expressionList
    : expression
    | expressionList ',' expression
    ;
~ End P4Grammar

The type of a list expression is a tuple type (Section
[#sec-synth-types]). List expressions can be assigned to ```tuple```, ```struct```
or ```header``` typed-values, or they can be passed as
arguments to methods. List expressions are not l-values. Nested lists
are permitted.

For example, the following example uses a list expression to pass
multiple header fields simultaneously to a learning provider:

~ Begin P4Example
extern LearningProvider {
    void learn<T>(in T data);
}
LearningProvider() unit;

unit.learn( { hdr.ethernet.srcAddr, hdr.ipv4.src } );
~ End P4Example

List expressions can be used as initializers to structures; in this
case, the list expression must have the same number of elements as the
number of fields in the destination structure; structure fields are
assigned in order with the values in the list expression:

~ Begin P4Example
struct S {
    bit<32> a;
    bit<32> b;
}
const S x = { 10, 20 };
~ End P4Example

List expressions can also be used to initialize variables whose type
is a ```tuple``` type:

~ Begin P4Example
tuple<bit<32>, bool> x = { 10, false };
~ End P4Example

## Set expressions { #sec-set-exprs }

Some P4 expressions denote sets of values (```set<T>```, for some type ```T```;
see Section [#sec-synth-types].1). These expressions can appear only in a
few contexts.

~ Begin P4Grammar
keysetExpression
    : tupleKeysetExpression
    | simpleKeysetExpression
    ;

tupleKeysetExpression
    : '(' simpleKeysetExpression ',' simpleExpressionList ')'
    ;

simpleExpressionList
    : simpleKeysetExpression
    | simpleExpressionList ',' simpleKeysetExpression
    ;

simpleKeysetExpression
    : expression
    | DEFAULT
    | DONTCARE
    | expression MASK expression
    | expression RANGE expression
    ;
~ End P4Grammar

The mask (```&&&```) and range (```..```) operators have the same
precedence, just above ```&```.

For example, the ```select``` expression (Section [#sec-select]) has
the following shape:

~ Begin P4Example
select (expression) {
    set1: state1;
    set2: state2;
   ...
}
~ End P4Example

In this context the expressions ```set1, set2```, etc. evaluate to
sets of values. The ```select``` expression tests whether its argument
belongs to any of the following sets.

### Singleton sets { #sec-singleton-set }

In a set context a simple expression denotes a set containing a single
element. For example:

~ Begin P4Example
select (hdr.ipv4.version) {
   4: continue;
}
~ End P4Example

The label ```4``` is a set expression denoting the set consisting of
the single value ```4```.

### The universal set { #sec-universal-set }

In a set context the ```default``` or ```_``` expressions denote a set
containing all possible elements.

~ Begin P4Example
select (hdr.ipv4.version) {
   4: continue;
   _: reject;
}
~ End P4Example

### Cubes { #sec-cubes }

The mask ```&&&``` infix operator takes two arguments of the same ```bit<W>```
type, and creates a value of type ```set<bit<W>>```. The right value is a "mask",
where each 0 bit in the mask indicates a "don't care" bit. The set denoted
by ```a &&& b``` is defined as

~ Begin P4Example
a &&& b = { c of type bit<W> where a & b = c & b }
~ End P4Example

(This set looks like a cube in the Cartesian space ```{0, 1}^W```.)
For example:

~ Begin P4Example
8w0x0A &&& 8w0x0F
~ End P4Example

denotes a set that contains 16 different 8-bit values, whose
bit-pattern is ```XXXX1010```, where the value of an ```X``` can be
any bit. Note that there may be multiple ways to express a keyset
using a mask operator; for example, ```8w0xFA &&& 8w0x0F``` denotes
the same keyset as in the example above.

P4 targets may impose additional restrictions on the expressions on
the left and right-hand side of a mask operator: for example, they may
require that either or both positions be compile-time known values.

### Ranges { #sec-ranges }

The range ```..``` infix operator takes two arguments of the same type ```T bit<W>```
or ```int<W>``` and creates a value of type ```set<T>```. The set contains all
values numerically between the first and the second, inclusively.  For example:

~ Begin P4Example
4w5 .. 4w8
~ End P4Example

denotes a set with values ```4w5, 4w6, 4w7```, and ```4w8```.

### Tuples of sets { #sec-tuples-of-sets }

Multiple set expressions can be grouped in a tuple using parentheses:

~ Begin P4Example
select(hdr.ipv4.ihl, hdr.ipv4.protocol) {
     (4w0x5, 8w0x1): parse_icmp;
     (4w0x5, 8w0x6): parse_tcp;
     (4w0x5, 8w0x11): parse_udp;
     (_, _): accept; }
~ End P4Example

The type of a tuple of sets is a set of tuples.

## Operations on struct types { #sec-ops-on-structs }

The only operation defined on values with a structure type is member
access operation, indicated using the dot (".") operator (e.g., ```s.field```).
Field extraction from an l-value produces an l-value. Structs can also be
copied using assignment; this is only possible between structs that have
the same type.

A struct object can be initialized with a list expression, as
described in Section [#sec-list-exprs].

## Operations on headers { #sec-ops-on-hdrs }

Headers provide the same operations as structs. Assignment between
headers also copies the "validity" header bit.

The method ```isValid()``` returns the value of the header's
"validity" bit.

The method ```setValid()``` sets the header's validity bit to
"true". It can only be applied to an l-value.

The method ```setInvalid()``` sets the header's validity bit to
"false". It can only be applied to an l-value.

The result of reading or writing a field in an invalid header is
undefined. The result of reading an uninitialized header field is
undefined --- even if the header itself is valid.

A header object can be initialized with a list expression, similar to
a struct --- the list fields are assigned to the header fields in the
order they appear.  In this case the header automatically becomes
valid:

~ Begin P4Example
header H { bit<32> x; bit<32> y; }
H h;
h = { 10, 12 };  // This also makes the header h valid
~ End P4Example

## Operations on header stacks { #sec-expr-hs }

A header stack is a fixed-size array of headers with the same
type. The valid elements of a header stack need not be contiguous. P4
provides a set of computations for manipulating header stacks. A
header stack ```hs``` declared as ```h[n]``` can be understood in
terms of the following pseudocode:

~ Begin P4Pseudo
// type declaration
struct hs_t {
  bit<32> nextIndex;
  bit<32> size;
  h[n] data;  // Ordinary array
}

// instance declaration and initialization
hs_t hs;
hs.nextIndex = 0;
hs.size = n;
~ End P4Pseudo

Intuitively, a header stack can be thought of as a struct containing
an ordinary array of headers ```hs``` and a counter ```nextIndex```
that can be used to simplify the construction of parsers for header
stacks, as discussed below. The ```nextIndex``` counter is initialized
to ```0```.

Given a header stack value ```hs``` of size ```n```, the following
expressions are legal:

- ```hs[index]```: result is a reference to the header at the
  specified position within the stack; if ```hs``` is an l-value, the
  result is also an l-value. The header may be invalid. Some targets
  may impose the constraint that the index expression evaluates to a
  compile-time known value. Accessing a header stack ``hs`` with an
  index less than ```0``` or greater than ```hs.size``` results in an
  undefined value.

- ```hs.size```: result is a 32-bit unsigned integer that returns the
  size of the header stack (a compile-time constant).

- assignment from a header stack ```hs``` into another stack requires
  the two stacks to have the same types and sizes. All components of ```hs```
  are copied, including its elements and their validity bits,
  as well as ```nextIndex```.

To help programmers write parsers for header stacks, P4 also offers
computations that automatically advance through the stack as elements
are parsed:

- ```hs.next```: result is a reference to the element with index ```hs.nextIndex```
  in the stack. May only be used in a ```parser```. If the stack's ```nextIndex```
  counter is greater than or equal to ```size```, then evaluating this
  expression results in a transition to the ```reject``` state and
  sets the error to ```error.StackOutOfBounds```. If ```hs``` is an
  l-value, then ```hs.next``` is also an l-value.

- ```hs.last```: result is a reference to the element with index ```hs.nextIndex - 1```
  in the stack, if such an element exists. May only be used in a ```parser```.
  If the ```nextIndex``` counter is less than ```1```,
  or greater than ```size```, then evaluating this expression results
  in a transition to the ```reject``` state and sets the error to ```error.StackOutOfBounds```.
  Unlike ```hs.next```, the resulting reference is never an l-value.

- ```hs.lastIndex```: result is an `int<32>` that encodes the index ```hs.nextIndex - 1```.
  May only be used in a ```parser```. If the ```nextIndex``` counter is ```0```, then
  evaluating this expression produces an undefined value.

Finally, P4 offers the following computations that can be used to
manipulate the elements at the front and back of the stack:

- ```hs.push_front(int count)```: shift "right" by ```count```. The
  first ```count``` elements become invalid. The last ```count```
  elements in the stack are discarded. The ```hs.nextIndex``` counter
  is incremented by ```count```. The ```count``` argument must be a
  positive integer that is a compile-time known value. The return type
  is ```void```.

- ```hs.pop_front(int count)```: shift "left" by ```count``` (i.e.,
  element with index ```count``` is copied in stack at index ```0```).
  The last ```count``` elements become invalid. The ```hs.nextIndex```
  counter is decremented by ```count```. The ```count``` argument must
  be a positive integer that is a compile-time known value. The return
  type is ```void```.

## Operations on header unions { #sec-expr-hu }

A variable declared with a union type is initially invalid:

~Begin P4Example
header H1 {
  bit<8> f;
}

header H2 {
  bit<16> g;
}

header_union U {
  H1 h1;
  H2 h2;
}

U u; // u invalid
~End P4Example

This also implies that each of the headers `h1` through `hn` contained
in it is also invalid. Unlike headers, a union cannot be initialized.

However, we can change the validity of a header union by assigning a
valid header to one of its elements:
~Begin P4Example
header H1
U u;
H1 my_h1 = { 8w0 }; // my_h1 is valid
u.h1 = my_h1;       // u and u.h1 are both valid
~End P4Example
We can also assign a list to an element of a header union,
~Begin P4Example
U u;
u.h2 = { 16w1 };     // u and u.h1 are valid
~End P4Example
or set their validity bits directly.
~Begin P4Example
U u;
u.h1.setValid();     // u and u.h1 are valid
H1 my_h1 = u.h1;     // my_h1 contains an undefined value
~End P4Example
Note that reading an uninitialized header produces an undefined value,
even if the header is itself valid.

More formally, if `u` is an expression whose type is a header union
`U` with fields ranged over by `hi`, then we can use the following
operations to manipulate the union value:

- `u.hi.setValid():` sets the valid bit for header `hi` to true and
  sets the valid bit for all other headers to false (which implies
  that reading these headers will return an unspecified value).

- `u.hi.setInvalid()`: if the valid bit for `hi` is true then sets it
  to false (which implies that reading u.hi will return an unspecified
  value); if the valid bit for `hi` is already false, then this
  expression has no effect. In particular, if `u.hj` was valid for
  some `hj` other than `hi` before `u.hi.setInvalid()` was invoked,
  then `u.hj` remains valid and its fields continue to have the same
  values as before.

We can understand an assignment to a union
~Begin P4Example
u.hi = e
~End P4Example
as equivalent to
~Begin P4Example
  u.hi.setValid();
  u.hi = e;
~End P4Example
if `e` is valid and
~Begin P4Example
  u.hi.setInvalid();
~End P4Example
otherwise.

Supplying an expression with a union type to `emit` simply emits the
single header that is valid, if any.

The following example shows how we can use header unions to represent
IPv4 and IPv6 headers uniformly:

~Begin P4Example
header_union IP {
    IPv4 ipv4;
    IPv6 ipv6;
}
struct Parsed_packet {
   Ethernet ethernet;
   IP ip;
}
parser top(packet_in b, out Parsed_packet p) {
    state start {
       b.extract(p.ethernet);
       transition select(p.ethernet.etherType) {
           16w0x0800 : parse_ipv4;
           16w0x86DD : parse_ipv6;
       }
   }
   state parse_ipv4 {
       b.extract(p.ip.ipv4);
       transition accept;
   }
   state parse_ipv6 {
       b.extract(p.ip.ipv6);
       transition accept;
   }
}
~End P4Example

As another example, we can also use unions to parse (selected) TCP
options:
~Begin P4Example
header Tcp_option_end_h {
    bit<8> kind;
}
header Tcp_option_nop_h {
    bit<8> kind;
}
header Tcp_option_ss_h {
    bit<8>  kind;
    bit<32> maxSegmentSize;
}
header Tcp_option_s_h {
    bit<8>  kind;
    bit<24> scale;
}
header Tcp_option_sack_h {
    bit<8>         kind;
    bit<8>         length;
    varbit<256>    sack;
}
header_union Tcp_option_h {
    Tcp_option_end_h  end;
    Tcp_option_nop_h  nop;
    Tcp_option_ss_h   ss;
    Tcp_option_s_h    s;
    Tcp_option_sack_h sack;
}

typedef Tcp_option_h[10] Tcp_option_stack;

struct Tcp_option_sack_top {
    bit<8> kind;
    bit<8> length;
}

parser Tcp_option_parser(packet_in b, out Tcp_option_stack vec) {
    state start {
        transition select(b.lookahead<bit<8>>()) {
            8w0x0 : parse_tcp_option_end;
            8w0x1 : parse_tcp_option_nop;
            8w0x2 : parse_tcp_option_ss;
            8w0x3 : parse_tcp_option_s;
            8w0x5 : parse_tcp_option_sack;
        }
    }
    state parse_tcp_option_end {
        b.extract(vec.next.end);
        transition accept;
    }
    state parse_tcp_option_nop {
         b.extract(vec.next.nop);
         transition start;
    }
    state parse_tcp_option_ss {
         b.extract(vec.next.ss);
         transition start;
    }
    state parse_tcp_option_s {
         b.extract(vec.next.s);
         transition start;
    }
    state parse_tcp_option_sack {
         bit<32> n = b.lookahead<Tcp_option_sack_top>().length;
         b.extract(vec.next.sack, n);
         transition start;
    }
}
~End P4Example

## Function calls, method invocations { #sec-functions }

Functions can be invoked using the function call syntax.

~ Begin P4Grammar
expression
    : ...
    | expression '<' typeArgumentList '>' '(' argumentList ')'
    | expression '(' argumentList ')'

argumentList
    : /* empty */
    | nonEmptyArgList
    ;

nonEmptyArgList
    : argument
    | nonEmptyArgList ',' argument
    ;

argument
    : expression
    ;

typeArgumentList
    : typeRef
    | typeArgumentList ',' typeRef
    ;
~ End P4Grammar

Function arguments are evaluated in order, left to right, before the
function invocation takes place. The calling convention is
copy-in/copy-out (Section 8.6). For generic functions the type
arguments can be explicitly specified in the function call. No
implicit casting is used for function arguments; the types of the
arguments must match the parameter types exactly.

Similar to the C programming language, the result returned by a
function call is discarded when the function call is used as a
statement.

## Constructor invocations { #sec-constructor }

Several P4 constructs denote resources that are allocated at
compilation time:

- ```extern``` objects
- ```parser```s
- ```control``` blocks
- ```package```s

Allocation of such objects can be performed in two ways:

- using constructor invocations, which are expressions that return an
  object of the corresponding type.
- using instantiations, described in Section
  [#sec-instantiations]. (Instantiations are similar to constant
  declarations.)

The syntax of a constructor invocation is similar to a function call.
Constructors are evaluated entirely at compilation-time (see Section
[#sec-p4-abstract-mach]). In consequence, all constructor arguments
must also be expressions that can be evaluated at compilation time.

The following example shows a constructor invocation for setting the
target-dependent implementation property of a table:

~ Begin P4Example
extern ActionProfile {
    ActionProfile(bit<32> size);  // constructor
}
table tbl {
    actions = { ... }
    implementation = ActionProfile(1024);  // constructor invocation
}
~ End P4Example

# Constants and variable declarations { #sec-consts-and-vars }

## Constants { #sec-constants }

Constant values are defined with the syntax:

~ Begin P4Grammar
constantDeclaration
    : optAnnotations CONST typeRef name '=' initializer ';'
    ;

initializer
    : expression
    ;
~ End P4Grammar

This introduces a constant whose value has the specified type. The
following are all legal constant declarations:

~ Begin P4Example
const bit<32> COUNTER = 32w0x0;
struct Version {
    bit<32> major;
    bit<32> minor;
}
const Version version = { 32w0, 32w0 };
~ End P4Example

The ```initializer``` expression must be a compile-time known value.

## Variables { #sec-variables }

Local variables can be declared using variable declarations:

~ Begin P4Grammar
variableDeclaration
    : annotations typeRef name optInitializer ';'
    | typeRef name optInitializer ';'
    ;

optInitializer
    : /* empty */
    | '=' initializer
    ;
~ End P4Grammar

Variables without an initializer are uninitialized (except for header
stacks, which have their ```nextIndex``` counter initialized to ```0```,
as discussed in [#sec-expr-hs]). The language places no restriction on
the types of the variables: most P4 types that can be written
explicitly can be used (e.g., base types, ```struct```, ```header```,
header stack, ```tuple```). One cannot declare variables with types
that are only synthesized by the compiler (e.g., ```set```), or with ```parser```, ```control```, ```package```,
or ```extern``` types. Objects of the latter types must be declared
using instantiations (see Section [#sec-instantiations]).

Reading the value of a variable that has not been initialized provides
an undefined result. The compiler should attempt to detect and flag
such reads statically.

Variables declarations can appear in the following places in a P4
program:

- In a block statement
- In a ```parser``` state
- In an ```action``` body
- In a ```control``` block apply block
- In the list of local declarations in a ```parser```
- In the list of local declarations in a ```control```

Variables are local, and behave like stack-allocated variables from
languages such as C. The value of a variable is never preserved from
one invocation of its enclosing block to the next, so variables cannot
be used to maintain state between different network packets.

## Instantiations { #sec-instantiations }

Instantiations are similar to variable declarations, but they are
reserved for the types with constructors (```extern``` objects, ```control```
blocks, ```parser```s, and ```package```s):

~ Begin P4Grammar
instantiation
    : typeRef '(' argumentList ')' name ';'
    | annotations typeRef '(' argumentList ')' name ';'
    ;
~ End P4Grammar

An instantiation looks like a constructor invocation followed by a
name.  Instantiations are always executed at compilation-time (Section
[#sec-ct-constants]). The effect is to allocate an object with the
specified name, and to bind it to the result of the constructor
invocation.

The following example shows how a hypothetical counter bank can be
instantiated:

~ Begin P4Example
// from target library
enum CounterType {
   Packets,
   Bytes,
   Both
}
extern Counter {
    Counter(bit<32> size, CounterType type);
    void increment(in bit<32> index);
}
// user program
control c(...) {
    Counter(32w1024, CounterType.Both) ctr;  // instantiation
    apply { ... }
}
~ End P4Example

A P4 program may only instantiate a single top-level package, as well
as the ```parser```s and ```control```s used to instantiate the
package, as specified by the architecture. This restriction is
designed to ensure that most state resides in the architecture itself,
or is local to a ```parser``` or ```control```. For example, the
following program is not valid,

~ Begin P4Example
// Architecture
control c(...);
control d(...);
package switch(c x, d y);

// Program
control c(...) { ... }
c() c1;
c() c2;

control d(...) {
  apply {
    ...
    c2.apply();
    ...
  }
}
d() d1;

switch(c1, d1);
~ End P4Example

because control `c2` is instantiated at the top-level, but is not
specified by the architecture. Note that top-level declarations of
constants and instantiations of extern objects are permitted.

# Statements { #sec-stmts }

Statements (except the block statement) must end with a semicolon,
C-style.

Statements can appear in several places:

- Within ```parser``` states
- Within a ```control``` block
- Within an ```action```

There are restrictions for the kinds of statements that can appear in
each of these places. For example, conditionals are not supported in
parsers, and ```switch``` statements are only supported in control
blocks. We present here the most general case, for control blocks.

~ Begin P4Grammar
statement
    : assignmentOrMethodCallStatement
    | conditionalStatement
    | emptyStatement
    | blockStatement
    | exitStatement
    | returnStatement
    | switchStatement
    ;

assignmentOrMethodCallStatement
    : lvalue '(' argumentList ')' ';'
    | lvalue '<' typeArgumentList '>' '(' argumentList ')' ';'
    | lvalue '='  expression ';'
    ;
~ End P4Grammar

In addition, parsers support a ```transition``` statement (Section
[#sec-transition]).

(Due to limitations in the Bison parser generator we have grouped all
productions starting with a l-value in the same rule.)

## Assignment { #sec-assignment }

Assignment is denoted with the ```=``` sign.

An assignment evaluates first the expression on the left hand side,
which must evaluate to an l-value, then the expression on the right
hand side, and copies that value into the left hand side. Derived
types (e.g. ```structs```) are copied recursively. ```header```s are
copied, including their "validity" bits. Assignment is not defined for ```extern```
values.

## The empty statement { #sec-emtpy-stmt }

The empty statement is a no-op.

~ Begin P4Grammar
emptyStatement
    : ';'
    ;
~ End P4Grammar

## The block statement { #sec-block-stmt }

A block statement is denoted by curly braces, as in C. It contains a
sequence of statements and declarations, which are executed
sequentially. The variables, constants, and instantiations within a
block statement are only visible within the block statement.

~ Begin P4Grammar
blockStatement
    : optAnnotations '{' statOrDeclList '}'
    ;

statOrDeclList
    : /* empty */
    | statOrDeclList statementOrDeclaration
    ;

statementOrDeclaration
    : variableDeclaration
    | constantDeclaration
    | statement
    | instantiation
    ;
~ End P4Grammar

## The return statement { #sec-return-stmt }

The ```return``` statement immediately terminates the execution of the ```action```
or ```control``` that contains the ```return```
statement. ```return``` statements are not allowed within parsers.

~ Begin P4Grammar
returnStatement
    : RETURN ';'
    ;
~ End P4Grammar

## The exit statement { #sec-exit-stmt }

The ```exit``` statement immediately terminates the execution of all
the blocks currently executing: the current ```action``` (if invoked
within an ```action```), the current ```control```, and all its
callers. ```exit``` statements are not allowed within parsers.

~ Begin P4Grammar
exitStatement
    : EXIT ';'
    ;
~ End P4Grammar

## The conditional statement { #sec-cond-stmt }

The conditional statement is very similar in syntax and semantics with
the corresponding C if statement. The only difference is that the only
acceptable type for the condition expression in P4 is boolean (and not
integer). The conditional statement cannot be used within a ```parser```.

~ Begin P4Grammar
conditionalStatement
    : IF '(' expression ')' statement
    | IF '(' expression ')' statement ELSE statement
    ;
~ End P4Grammar

When using nested ```if``` statements, the ```else``` applies to the
innermost ```if``` that does not have an ```else``` statement.

## The switch statement { #sec-switch-stmt }

The ```switch``` can only be used within ```control``` blocks.

~ Begin P4Grammar
switchStatement
    : SWITCH '(' expression ')' '{' switchCases '}'
    ;

switchCases
    : /* empty */
    | switchCases switchCase
    ;

switchCase
    : switchLabel ':' blockStatement
    | switchLabel ':'  // fall-through
    ;

switchLabel
    : name
    | DEFAULT
    ;
~ End P4Grammar

The expression within the ```switch``` statement is restricted to be
the result of a table's invocation (more details are given in Section
[#sec-invoke-mau]).

If a switch label is not followed by a block statement it is
fall-through to the next label. However, if a block statement is
present, there is no fall-through. Note, that this is different from C ```switch```
statements, where a ```break``` is needed to prevent
fall-through. It is legal to have no matching label for some actions,
or no ```default``` label. No label can appear twice in a switch
statement.

~ Begin P4Example
switch (t.apply().action_run) {
   action1:          // fall-through to action2:
   action2: { ...}
   action3: { ...}  // no fall-through from action2 to action3 labels
}
~ End P4Example

Please note that the ```default``` label of the ```switch``` statement
is used to match on the kind of action executed, no matter whether
there was a table hit or miss. The ```default``` label does not
indicate that the table missed and the ```default_action``` was
executed.

# Packet parsing in P4 { #sec-packet-parsing }

This section describes the P4 constructs specific to parsing network packets.

## Parser states { #sec-parser-states }

~ Figure { #fig-parserstatemachine; caption: "Parser FSM structure." }
![parserstatemachine]
~
[parserstatemachine]: figs/parserstatemachine.png { height: 5cm; page-align: here }

[]{tex-cmd: "\indent"}
A P4 parser describes a state-machine with one start state and two
final states. The start state is always named ```start```.  The two
final states are named ```accept``` (indicating successful parsing)
and ```reject``` (indicating a parsing failure). The ```start``` state
is part of the parser, while the ```accept``` and ```reject``` states
are logically outside of the parser.  Figure [#fig-parserstatemachine]
illustrates the general structure of a parser state-machine.

## Parser declarations { #sec-parser-decl }

P4 programmers are expected to provide parser declarations for all
programmable parsers of a target.

~ Begin P4Grammar
parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      '{' parserLocalElements parserStates '}'
    ;

parserLocalElements
    : /* empty */
    | parserLocalElements parserLocalElement
    ;

parserStates
    : parserState
    | parserStates parserState
    ;
~ End P4Grammar

Parsers cannot be generic (unlike parser type declarations); thus when
used in the context of a `parserDeclaration` the
`parserTypeDeclaration` cannot contain any type parameters.  I.e., the
following declaration is illegal:

~ Begin P4Example
parser P<H>(inout H data) { ... }
~ End P4Example

At least one state, named ```start```, must be present in any ```parser```.
A parser cannot contain two states with the same name. A parser cannot
define the ```accept``` and ```reject``` states; these are logically
outside of the parser.

State declarations are described below. Preceding the parser states, a ```parser```
may also contain a list of local elements. These can be constants,
variables, or instantiations of objects that may be used within the
parser. Such objects may be instantiations of ```extern``` objects, or
other ```parser```s that may be invoked as subroutines. P4 forbids the
instantiation of ```control``` blocks within a ```parser```.

~ Begin P4Grammar
parserLocalElement
    : constantDeclaration
    | variableDeclaration
    | instantiation
    ;
~ End P4Grammar

For an example containing a complete declaration of a parser see
Section [#sec-vss-all].

For a description of the ```optConstructorParameters```, used for
building parameterized parsers, see Section [#sec-parametrization].

## The Parser abstract machine { #sec-parser-abstract-machine }

We explain the semantics of P4 parsers program using an abstract
machine that manipulates a data structure named ```ParserModel```. The
abstract machine is described using pseudo-code.

A parser starts execution in the ```start``` state and ends execution
when one of the ```reject``` or ```accept``` states has been reached.

~ Begin P4Pseudo
ParserModel {
    error       parseError;
    state       currentState;
    onPacketArrival(packet p) {
        ParserModel.parseError = error.NoError;
        ParserModel.currentState = start;
        execute(ParserModel.currentState);
    }
}
~ End P4Pseudo

The target architecture must specify its behavior for packets that
are ```accept```ed and ```reject```ed. For example, an architecture may
specify that all packets reaching the ```reject``` state are dropped
without any further processing. Another architecture may specify that
such packets are always passed on to the next control block after the
parser, with intrinsic metadata indicating that the parser reached
the ```reject``` state, along with any error recorded.

## Parser states { #sec-parser-state-stmt }

A parser state has a name and a body. The body of the state describes
data processing performed when the parser transitions to the specified
state. This data processing may consist of:

- Data extraction from packet into headers
- Invocations of methods of ```extern``` blocks (e.g., checksum
  computations)
- Checks for data validity
- Transition to other states

A state is declared with the following syntax:
~ Begin P4Grammar
parserState
    : optAnnotations STATE name
     '{' parserStatements transitionStatement '}'
    ;
~ End P4Grammar

~ Begin P4Grammar
parserStatements
    : /* empty */
    | parserStatements parserStatement
    ;

parserStatement
    : assignmentOrMethodCallStatement
    | variableDeclaration
    | constantDeclaration
    | parserBlockStatement
    ;

parserBlockStatement
    : optAnnotations '{' parserStatements '}'
    ;
~ End P4Grammar

The state body contains a sequence of:

- local variable declarations
- assignment statements
- method calls. These can serve multiple purposes:
  * ```verify``` calls
  * method invocations (e.g., for extracting data out of packets),
  * invocations of other parsers.

The parser state body ends with an optional ```transition```
statement, which transfers control to the next state. Certain targets
may place restrictions on the complexity of the expressions that can
be evaluated while executing a parser.

**Semantics**: The execution of a state entails the sequential
  execution of the statements in the state body.

## Transition statements { #sec-transition }

The ```transition``` statement has the following syntax:
~ Begin P4Grammar
transitionStatement
    : /* empty */
    | TRANSITION stateExpression
    ;

stateExpression
    : name ';'
    | selectExpression
    ;
~ End P4Grammar

The execution of the transition statement causes ```stateExpression```
to be evaluated, and the flow of control to be transferred to the
resulting state.

**Semantics**: in terms of the ParserModel the above statement is
  equivalent to:

~ Begin P4Example
ParserModel.currentState = eval(stateExpression)
~ End P4Example

For example, this statement:

~ Begin P4Example
transition accept;
~ End P4Example

will terminate the execution of the current parser transitioning to
the ```accept``` state.

If the body of a state block does not end with a ```transition```
statement, the implied statement is

~ Begin P4Example
transition reject;
~ End P4Example

## Select expressions { #sec-select }

A ```select``` expression evaluates to a state. The syntax is the
following:

~ Begin P4Grammar
selectExpression
    : SELECT '(' expressionList ')' '{' selectCaseList '}'
    ;

selectCaseList
    : /* empty */
    | selectCaseList selectCase
    ;

selectCase
    : keysetExpression ':' name ';'
    ;
~ End P4Grammar

If expressionList has type ```tuple<T>```, all ```keysetExpression```
must have type ```set<tuple<T>>```.

**Semantics**: the meaning of the following select expression:

~ Begin P4Example
select(e) {
    ks[0]: s[0];
    ks[1]: s[1];
    ...
    ks[n-2]: s[n-1];
    _ : sd;  // ks[n-1] is default
}
~ End P4Example

is defined in pseudo-code as:

~ Begin P4Pseudo
key = eval(e);
for (int i=0; i < n; i++) {
    keyset = eval(ks[i]);
    if (keyset.contains(key)) return s[i];
}
verify(false, error.NoMatch);
~ End P4Pseudo

Some targets may require that all keyset expressions in a select
expression must be compile-time known values. Keysets are evaluated in
order, from top to bottom as implied by the pseudo-code above; the
first keyset that includes the value in the ```select``` argument
provides the result state. If no label matches, the execution triggers
a runtime error with the standard error code ```error.NoMatch```.

Note that this implies that all cases after a ```default``` or ```_```
label are unreachable; the compiler should emit warnings about this
case. This constitutes an important difference between ```select```
expression and ```switch``` statement in C language, where the order
does not matter; the keysets of a ```select``` expression may
"overlap").

The most typical case for using ```select``` expressions is to compare
the value of a field from a recently-extracted header against a set of
constant values, as in the following example:

~ Begin P4Example
header IPv4_h { ... bit<8> protocol; ... }
struct P { ... IPv4_h ipv4; ... }
P headers;
select (headers.ipv4.protocol) {
    8w6  : parse_tcp;
    8w17 : parse_udp;
    _    : accept;
}
~ End P4Example

For example, to detect TCP reserved ports (< 1024) one could write:

~ Begin P4Example
select (p.tcp.port) {
    16w0 &&& 16w0xFC00: well_known_port; // top 6 bits are zero
    _: other_port;
}
~ End P4Example

The expression ```16w0 &&& 16w0xFC00``` describes the set of 16-bit
values that have their top 6 bits zero.

## verify { #sec-verify }

The ```verify``` statement provides a simple form of error
handling. ```verify``` can only be invoked within a parser; it is used
syntactically as if it were a function with the following signature:

~ Begin P4Example
extern void verify(in bool condition, in error err);
~ End P4Example

If the first argument is ```true```, the execution of the statement
has no side-effects. If the first argument is ```false```, it causes
an immediate transition to the ```reject``` state, which causes
immediate parsing termination; at the same time, the ```parserError```
associated with the parser is set to the value of the second argument.

**Semantics**: in terms of the ```ParserModel``` the semantics of a ```verify```
  statement is given by:

~ Begin P4Pseudo
ParserModel.verify(bool condition, error err) {
    if (condition == false) {
        ParserModel.parserError = err;
        ParserModel.currentState = reject;
    }
}
~ End P4Pseudo

## Data extraction from packets { #sec-packet-data-extraction }

The P4 core library contains the following declaration of a built-in ```extern```
type called ```packet_in``` that represents incoming network
packets. The ```packet_in``` extern is special: it cannot be
instantiated by the user explicitly. Instead, the architecture
supplies a separate instance for each ```packet_in``` argument to a
top-level ```parser``` or ```control``` block.

~ Begin P4Example
extern packet_in {
    void extract<T>(out T headerLvalue);
    void extract<T>(out T variableSizeHeader, in bit<32> varFieldSizeBits);
    T lookahead<T>();
    bit<32> length();  // This method may be unavailable in some architectures
    void advance(bit<32> bits);
}
~ End P4Example

To extract data from a packet represented by an argument ```b``` with
type ```packet_in```, a parser invokes the ```extract``` methods of ```b```.
There are two variants of the ```extract``` method: a one-argument
variant for extracting fixed-size headers, and a two-argument variant
for extracting variable-sized headers. Because these operations can
cause runtime verification failures (see below), these methods can
only be executed within parsers.

When extracting data into a bit-string or integer, the first packet
bit is extracted to the most significant bit of the integer.

Some targets may perform cut-through packet processing, i.e., they may
start processing a packet before its length is known (i.e., before all
bytes have been received). On such a target calls to the ```packet_in.length()```
method cannot be implemented. Attempts to call this method should be
flagged as errors (either at compilation time by the compiler
back-end, or when attempting to load the compiled P4 program onto a
target that does not support this method).

**Semantics**: we describe the semantics of these operations in terms
  of the following abstract model of a packet data structure
  (pseudo-code):

~ Begin P4Pseudo
packet_in {
    unsigned nextBitIndex;
    byte[] data;
    unsigned lengthInBits;
    void initialize(byte[] data) {
        this.data = data;
        this.nextBitIndex = 0;
        this.lengthInBits = data.sizeInBytes * 8;
    }
    bit<32> length() { return this.lengthInBits / 8; }
}
~ End P4Pseudo

### extract --- single argument { #sec-packet-extract-one }

The single-argument extract method has the following P4 declaration:
~ Begin P4Example
void extract<T>(out T headerLeftValue);
~ End P4Example

The expression ```headerLeftValue``` should evaluate to a l-value (see
Section [#sec-lvalues]) of type ```header``` with a fixed width. If
this method executes successfully, on completion the ```headerLvalue```
is filled with data from the packet and its validity bit is set. This
method may fail by executing a failed ```verify``` call (e.g., not
enough bits left in packet to fill the specified header). For example,
to extract an Ethernet header one can invoke:

~ Begin P4Example
struct Result { ... Ethernet_h ethernet; ... }
parser P(packet_in b, out Result r) {
    state start {
        b.extract(r.ethernet);
    }
}
~ End P4Example

**Semantics**: the semantics of extract is given in terms of the
  following pseudo-code method of the ```packet``` class shown
  above. We use the special ```valid$``` identifier to indicate the
  hidden valid bit of a header, ```isNext$``` to indicate that the
  l-value was obtained using ```next```, and ```nextIndex$``` to
  indicate the corresponding header stack properties.

~ Begin P4Pseudo
void packet_in.extract<T>(out T headerLValue) {
   bitsToExtract = sizeofInBits(headerLValue);
   lastBitNeeded = this.nextBitIndex + bitsToExtract;
   ParserModel.verify(this.lengthInBits >= lastBitNeeded, error.PacketTooShort);
   headerLValue = this.data.extractBits(this.nextBitIndex, bitsToExtract);
   headerLValue.valid$ = true;
   if headerLValue.isNext$ {
     verify(headerLValue.nextIndex$ < headerLValue.size, error.StackOutOfBounds);
     headerLValue.nextIndex$ = headerLValue.nextIndex$ + 1;
   }
   this.nextBitIndex += bitsToExtract;
}
~ End P4Pseudo

### extract --- two arguments { #sec-packet-extract-two }

The two-argument extract method has the following declaration:

~ Begin P4Example
void extract<T>(out T headerLvalue, in bit<32> variableFieldSize);
~ End P4Example

The expression ```headerLvalue``` must be a l-value representing a
header that contains *exactly one* ```varbit```
field. ```variableFieldSize``` is an expression evaluating to a ```bit<32>```
value which indicates the number of bits to be extracted into the
unique ```varbit``` field of the header (this size is not the size of
the complete header, just the size of the ```varbit``` field).

**Semantics**: the semantics of a two-argument extract invocation is
  given in terms of the following pseudo-code:

~ Begin P4Pseudo
void packet_in.extract<T>(out T headerLvalue,
                          in bit<32> variableFieldSize) {
   bitsToExtract = sizeOfFixedPart(headerLvalue) + variableFieldSize;
   lastBitNeeded = this.nextBitIndex + bitsToExtract;
   ParserModel.verify(this.lengthInBits >= lastBitNeeded, error.PacketTooShort);
   ParserModel.verify(bitsToExtract <= headerLvalue.maxSize, error.HeaderTooShort);
   headerLvalue = this.data.extractBits(this.nextBitIndex, bitsToExtract);
   headerLvalue.varbitField.size = variableFieldSize;
   headerLvalue.valid$ = true;
   if headerLValue.isNext$ {
     verify(headerLValue.nextIndex$ < headerLValue.size, error.StackOutOfBounds);
     headerLValue.nextIndex$ = headerLValue.nextIndex$ + 1;
   }
   this.nextBitIndex += bitsToExtract;
}
~ End P4Pseudo

The example below shows one way that IPv4 options can be extracted by
splitting the IPv4 header into two separate headers:

~ Begin P4Example
// IPv4 header without options
header IPv4_no_options_h {
   bit<4>   version;
   bit<4>   ihl;
   bit<8>   diffserv;
   bit<16>  totalLen;
   bit<16>  identification;
   bit<3>   flags;
   bit<13>  fragOffset;
   bit<8>   ttl;
   bit<8>   protocol;
   bit<16>  hdrChecksum;
   bit<32>  srcAddr;
   bit<32>  dstAddr;
}

header IPv4_options_h {
   varbit<320> options;
}

struct Parsed_headers {
    ...
    IPv4_no_options_h ipv4;
    IPv4_options_h    ipv4options;
}

error { InvalidIPv4Header }

parser Top(packet_in b, out Parsed_headers headers) {
   ...
   state parse_ipv4 {
       b.extract(headers.ipv4);
       verify(headers.ipv4.ihl >= 5, error.InvalidIPv4Header);
       transition select (headers.ipv4.ihl) {
           5: dispatch_on_protocol;
           _: parse_ipv4_options;
   }

   state parse_ipv4_options {
       b.extract(headers.ipv4options,
                 (bit<32>)(((bit<16>)headers.ipv4.ihl - 5) * 32));
       transition dispatch_on_protocol;
   }
}
~ End P4Example

### Lookahead { #sec-packet-lookahead }

The ```lookahead``` method provided by the ```packet_in``` packet
abstraction evaluates to a set of bits from the input packet without
advancing the ```nextBitIndex``` pointer. Similar to ```extract```, it
will transition to ```reject``` and set the error if there are not
enough bits in the packet. One invokes ```lookahead``` as follows:

~ Begin P4Example
b.lookahead<T>()
~ End P4Example

where ```T``` must be a type with fixed width. In case of success the
result of the evaluation of ```lookahead``` returns a value of type ```T```.

**Semantics**: in terms of the abstract model the semantics of
  lookahead is given by the following pseudo-code:

~ Begin P4Pseudo
T packet_in.lookahead<T>() {
   bitsToExtract = sizeof(T);
   lastBitNeeded = this.nextBitIndex + bitsToExtract;
   ParserModel.verify(this.lengthInBits >= lastBitNeeded, error.PacketTooShort);
   T tmp = this.data.extractBits(this.nextBitIndex, bitsToExtract);
   return tmp;
}
~ End P4Pseudo

Examples:

~ Begin P4Example
header Tcp_option_sack_top { ...}
state start {
    transition select(b.lookahead<bit<8>>()) {
        0: parse_tcp_option_end;
        1: parse_tcp_option_nop;
        2: parse_tcp_option_ss;
        3: parse_tcp_option_s;
        5: parse_tcp_option_sack;
    }
}
state parse_tcp_option_sack {
     b.extract(vec.next.sack,
               (bit<32>)(b.lookahead<Tcp_option_sack_top>().length));
     transition next;
}
~ End P4Example

### Skipping bits { #sec-skip-bits }

There are two ways to skip over bits in an input packet without
assigning them to a header:

One can extract to the underscore identifier, by specifying explicitly
the type of the data:

~ Begin P4Example
b.extract<T>(_)
~ End P4Example

Alternatively, one can use the ```advance``` method of the packet when
the number of bits to skip is known. The meaning of this method is
given in pseudo-code as:

~ Begin P4Pseudo
void packet_in.advance(bit<32> bits) {
   lastBitNeeded = this.nextBitIndex + bits;
   ParserModel.verify(this.lengthInBits >= lastBitNeeded, error.PacketTooShort);
   this.nextBitIndex += bits;
}
~ End P4Pseudo

## Parsing header stacks { #sec-parse-header-stacks }

During parsing, a header stack provides two properties: ```next``` and ```last```.
Consider the following declaration, which defines a stack for
representing the headers of a packet with at most 10 MPLS headers:

~ Begin P4Example
header Mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit     bos;
    bit<8>  ttl;
}
Mpls_h[10] mpls;
~ End P4Example

The expression ```mpls.next``` represents an l-value of type ```Mpls_h```
that references an element in the ```mpls```
stack. Initially, ```mpls.next``` refers to the first element of
stack. It is automatically advanced on each successful call to ```extract```.
The ```mpls.last``` property refers to the element
immediately preceding ```next``` if such an element exists. Attempting
to access ```mpls.next``` element when the stack's ```nextIndex```
counter is greater than or equal to ```size``` causes a transition to ```reject```
and sets the error to ```error.StackOutOfBounds```. Likewise,
attempting to access ```mpls.last``` when the ```nextIndex``` counter
is equal to ```0``` causes a transition to the ```reject``` state and
sets the error to ```error.StackOutOfBounds```.

The following example shows a simplified parser for MPLS processing:

~ Begin P4Example
struct Pkthdr {
   Ethernet_h ethernet;
   Mpls_h[3] mpls;
   // other headers omitted
}
parser P(packet_in b, out Pkthdr p) {
    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
           0x8847: parse_mpls;
           0x0800: parse_ipv4;
        }
    }
    state parse_mpls {
         b.extract(p.mpls.next);
         transition select(p.mpls.last.bos) {
            0: parse_mpls; // This creates a loop
            1: parse_ipv4;
         }
    }
    // other states omitted
}
~ End P4Example

## Invoking sub-parsers { #sec-invoke-subparser }

P4 allows parsers to invoke the services of other parsers, similar to
subroutines. To invoke the services of another parser, the sub-parser
must be first instantiated; the services of an instance are invoked by
calling it using its apply method.

The following example shows a sub-parser invocation:

~ Begin P4Example
parser callee(packet_in packet, out IPv4 ipv4) { ...}
parser caller(packet_in packet, out Headers h) {
     callee() subparser;  // instance of callee
     state subroutine {
          subparser.apply(packet, h.ipv4);  // invoke sub-parser
     }
}
~ End P4Example

Semantics: the semantics of a subparser invocation can be described as
follows:

- The state invoking the sub-parser is split into two half-states at
  the parser invocation statement.
- The top half includes a transition to the sub-parser ```start```
  state.
- The sub-parser's ```accept``` state is identified with the bottom
  half of the current state
- The sub-parser's ```reject``` state is identified with the reject
  state of the current parser.

~ Figure { #fig-subparser; caption: "Semantics of invoking a sub-parser:  top: original program, bottom: equivalent program." }
![subparser]
~
[subparser]: figs/subparser.png { width: 60%; page-align: here }

[]{tex-cmd: "\indent"}
Figure [#fig-subparser] shows a diagram of this process.

Since P4 requires declarations to precede uses, it is impossible to
create recursive (or mutually recursive) parsers.

Various targets may impose (static or dynamic) constraints on the
number of parser states that can be traversed for processing each
packet. For example, a specific compiler implementation may reject
parsers where loops cannot be unrolled at compilation time, or it may
reject parser cycles that do not advance the cursor within the parsed
packet. If a parser aborts execution dynamically because it exceeded
the maximum time budget allocated, the parser error should be set to
the standard error ```error.ParserTimeout```.

# Control blocks { #sec-control }

P4 parsers are responsible for extracting bits from a packet into
headers. The headers can be manipulated and transformed within ```control```
blocks. Control blocks are a P4 construct that are used
for describing match-action pipelines. The body of a control block
resembles a traditional C program. Within the body of a control block,
match-action units can be invoked to perform data
transformations. Match-action units are represented in P4 by
constructs called ```tables```.

There is no exceptional control-flow in a ```control``` block: no
equivalent of the ```verify``` parser statement or of the ```reject```
state. Error handling has to be performed explicitly by users.

P4 forbids the instantiation of ```parser``` instances within a ```control```
block.

A ```control``` block may start with declarations of ```action```s, ```table```s,
constants, variables, and instantiations.

~ Begin P4Grammar
controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      /* controlTypeDeclaration cannot contain type parameters */
      '{' controlLocalDeclarations APPLY controlBody '}'
    ;

controlLocalDeclarations
    : /* empty */
    | controlLocalDeclarations controlLocalDeclaration
    ;

controlLocalDeclaration
    : constantDeclaration
    | variableDeclaration
    | actionDeclaration
    | tableDeclaration
    | instantiation
    ;

controlBody
    : blockStatement
    ;
~ End P4Grammar

Controls cannot be generic (unlike control type declarations); thus
when used in the context of a `controlDeclaration` the
`controlTypeDeclaration` cannot contain any type parameters.  I.e.,
the following declaration is illegal:

~ Begin P4Example
control C<H>(inout H data) { ... }
~ End P4Example

For a description of the ```optConstructorParameters```, which can be
used to build parameterized control blocks, see Section
[#sec-parametrization].

We start by describing the core components of a ```control``` block,
starting with actions.

## Actions { #sec-actions}

~ Figure { #fig-actions; caption: "Actions contain code and data. The code is in the P4 program, while the data is set by the control plane. Parameters are bound by the data plane." }
![actions]
~
[actions]: figs/actions.png { width: 8cm; page-align: here }

[]{tex-cmd: "\indent"}
Actions are code fragments that can read and write the data being
processed. Actions may contain data values that can be written by the
control plane and read by the data plane. Actions are the fundamental
construct by which the control-plane can influence dynamically the
behavior of the data plane. Figure [#fig-actions] shows the abstract
model of an ```action```. Formally, actions are function objects
<https://en.wikipedia.org/wiki/Function_object>.

~ Begin P4Grammar
actionDeclaration
    : optAnnotations ACTION name '(' parameterList ')' blockStatement
    ;
~ End P4Grammar

Syntactically actions resemble functions with no return
values. Actions may be declared within a control block; in this case
they can only be used within an instance of that control block.

The following example shows an action declaration:
~ Begin P4Example
action Forward_a(out bit<9> outputPort, bit<9> port) {
    outputPort = port;
}
~ End P4Example

Action parameters may not have ```extern``` types. Action parameters
that have no direction (e.g., ```port``` in the previous example)
indicate action data. All such parameters must be at the end of the
parameter list. For actions that appear in a table actions list
(described in Section [#sec-table-action-list]), these parameters are
bound by the control plane.

The body of an action consists of a sequence of statements and
declarations. No switch statements are allowed within an action (the
grammar as written permits them, but a semantic check should reject
them). Some targets may impose additional restrictions on action
bodies---e.g., only straight-line code, with no ```if``` statements or
conditional expressions (```?:```).

### Invoking actions { #sec-invoke-actions }

Actions can be executed in two ways:

- Actions can be implicitly invoked by tables during match-action
  processing.
- Actions can be explicitly invoked, either from a ```control``` block
  or from another ```action```. In this case, values for all action
  parameters must be supplied explicitly, including values for the
  directionless parameters. The directionless parameters in this case
  behave like ```in``` parameters.

## Tables { #sec-tables }
~ Figure { #fig-maudataflow; caption: "Match-Action Unit Dataflow." }
![maudataflow]
~
[maudataflow]: figs/maudataflow.png { width: 80%; page-align: here }

[]{tex-cmd: "\indent"}
The P4 ```table``` construct describes a match-action unit. The
structure of a match-action unit is shown in Figure
[#fig-maudataflow]. The match-action processing consists of the
following steps:

- Key construction.
- Key lookup in a lookup table (the "match" step). The result of key
  lookup is an "action".
- Action execution (the "action step") over the input data, resulting
  in mutations of the data.

A ```table``` declaration introduces a table instance. If one desires
to instantiate a table multiple times one needs to declare a table in
a separate control block and instantiate that control block multiple
times.

The look-up table is a finite map whose contents are manipulated
asynchronously (read/write) by the target control-plane, through a
separate control-plane API (see Figure [#fig-maudataflow]). Note that
the term "table" is overloaded: it can refer to the P4 ```table```
objects that appear in P4 programs, as well as the internal look-up
tables used in targets. In this document, we use the term
"match-action unit" whenever possible instead of "table".

Syntactically a table is described by a set of key-value
properties. Some of these properties are "standard" properties, but
the set of properties can be extended by target-specific compilers as
needed.

~ Begin P4Grammar
tableDeclaration
    : optAnnotations TABLE name '{' tablePropertyList '}'
    ;

tablePropertyList
    : tableProperty
    | tablePropertyList tableProperty
    ;

tableProperty
    : KEY '=' '{' keyElementList '}'
    | ACTIONS '=' '{' actionList '}'
    | optAnnotations CONST IDENTIFIER '=' initializer ';'
    | optAnnotations IDENTIFIER '=' initializer ';'
    ;
~ End P4Grammar

The standard table properties include:

- ```key```: An expression that describes how the key used for look-up
  is computed.
- ```actions```: A list of all actions that may be found in the table.

In addition, the tables may optionally define the following property,

- ```default_action```: an action to execute when the lookup in the
  lookup table fails to find a match for the key used.

as well as architecture-specific properties (see
Sec. [#sec-additional-table-properties]).

We discuss each of these properties in detail.

A property marked as ```const``` cannot be changed dynamically by the
control-plane. The ```key``` and ```actions``` properties are always
constant, so the ```const``` keyword is not needed for these.

### Table properties { #sec-table-props }

#### Table keys

The ```key``` is a table property which specifies the key used when
looking up an action in the lookup table. The key is given by a set of
pairs (expression : matchKind):

~ Begin P4Grammar
keyElementList
    : /* empty */
    | keyElementList keyElement
    ;

keyElement
    : expression ':' name optAnnotations ';'
    ;
~ End P4Grammar

Each name in a ```keyElement``` must be a constant of type ```match_kind```
(see Section [#sec-match-kind-type]).

For example, let us consider the following ```table``` declaration fragment:

~ Begin P4Example
table Fwd {
    key = {
       ipv4header.dstAddress : ternary;
       ipv4header.version    : exact;
    }
    ...
}
~ End P4Example

In this example the lookup key is composed of two fields of the ```ipv4header```
structure: ```dstAddress``` and ```version```. The ```match_kind``` information
attached to each key expression is used for two purposes:

- It is used to synthesize the control-plane API that is used to
  populate the table. The control-plane API specification is part of a
  separate document.
- It is used by the compiler back-end to allocate resources for the
  table's implementation.

The P4 core library contains three predefined ```match_kind```
identifiers:

~ Begin P4Example
match_kind {
   exact,
   ternary,
   lpm
}
~ End P4Example

These identifiers correspond to the P4~14~ match kinds with the same
names. The semantics of these annotations is actually irrelevant for
describing the behavior of the P4 abstract machine; how they are used
influences only the control-plane API and the actual implementation of
the look-up table. From the point of view of the P4 program, a look-up
table is an abstract finite map that is given a key and produces as a
result either an action or a "miss" indication, as described in
Section [#sec-mau-semantics].

If a table has no ```key``` property, then it contains no look-up
table, just a default action, which is always executed (i.e., the
associated lookup table is always the empty map).

Each key element can have an optional ```@name``` annotation which is
used to synthesize the control-plane visible name for the key field.

#### The list of actions { #sec-table-action-list }

A table must declare all possible actions that may appear within the
associated lookup table or in the default action. This is done with
the ```actions``` property; the value of this property is always an ```actionList```:

~ Begin P4Grammar
actionList
    : actionRef ';'
    | actionList actionRef ';'
    ;

actionRef
    : optAnnotations name
    | optAnnotations name '(' argumentList ')'
    ;
~ End P4Grammar

Let us consider an example from the Very Simple Switch program in
Section [#sec-vss-all]:

~ Begin P4Example
action Drop_action()
{ outCtrl.outputPort = DROP_PORT; }

action Rewrite_smac(EthernetAddress sourceMac)
{ headers.ethernet.srcAddr = sourceMac; }

table smac {
    key = { outCtrl.outputPort : exact; }
    actions = {
        Drop_action;
        Rewrite_smac;
    }
}
~ End P4Example

- The ```smac``` ```table``` can contain two types of actions, named ```Drop_action```
  and ```Rewrite_mac```.
- The ```Rewrite_smac``` action has one parameter, which is bound by
  the control plane.

All actions in the list of actions of a table must have different
names; e.g., the following program fragment is illegal:

~ Begin P4Example
action a() {}
control c() {
    action a() {}
    // Illegal table: two actions with the same name
    table t { actions = { a; .a; } }
}
~ End P4Example

Each action parameter that has a direction (```in```, ```inout```, or ```out```)
must be bound in the ```actions``` list specification; conversely, no
directionless parameters may be bound in the list. The expressions
supplied as arguments to an ```action``` are not evaluated until the
action is invoked.

~ Begin P4Example
action a(in bit<32> x) { ...}
bit<32> z;
action b(inout bit<32> x, bit<8> data) { ...}
table t {
    actions = {
       // a; -- illegal, x parameter must be bound
       a(5);  // binding a's parameter x to 5
       b(z);  // binding b's parameter x to z
       // b(z, 3);  // -- illegal, cannot bind directionless data parameter
       // b(); -- illegal, x parameter must be bound
    }
}
~ End P4Example

#### The default action

The default action of a table is an action that is invoked
automatically by the match-action unit whenever the lookup table does
not find a match for the supplied key.

If present, the ```default_action``` property _must_ appear after the ```action```
property. It may be declared as ```const```, indicating that it cannot
be changed dynamically by the control-plane. The ```default action```
_must_ be one of the actions that appear in the actions list. In
particular, the expressions passed as ```in```, ```out```, or ```inout```
parameters must be syntactically identical to the expressions used in
one of the elements of the ```actions``` list.

For example, in the above ```table``` we could set the default action
as follows (marking it also as constant --- i.e., not changeable by
the control plane):

~ Begin P4Example
const default_action = Rewrite_smac(48w0xAA_BB_CC_DD_EE_FF);
~ End P4Example

Note that the specified default action must supply arguments for the
control-plane bound parameters (i.e., the directionless parameters),
since the action is synthesized at compilation time. The expressions
supplied as arguments for parameters with a direction (```in```, ```inout```,
or ```out```) are evaluated when the action is invoked while the
expressions supplied as arguments for directionless parameters are
evaluated at compile time.

Continuing the example in the previous section, here are various legal
and illegal specifications for ```table t``` above:

~ Begin P4Example
  default_action = a(5); // OK - no control-plane parameters
  // default_action = a(z); -- illegal, a's x parameter is already bound to 5
  default_action = b(z,8w8); // OK - bind b's data parameter to 8w8
  // default_action = b(z); -- illegal, b's data parameter is not bound
~ End P4Example

If a table does not specify the ```default_action``` property and no
entry matches a given packet, then the table does not affect the
packet and processing continues according to the imperative control
flow of the program.

#### Table entries

A table may be initialized at compile-time with a set of
entries. While it is typical that entries are installed in tables by
the contol plane program, there are situations in which tables are
used to implement fixed algorithms. In such cases, defining the
entries that enable the execution of the algorithm in the P4 source,
allows the compiler to infer how the table is actually used and
potentially make better placement decisions for tagets with constraint
resources. Entries declared in the P4 source are installed in the
table at program load time.

~ Begin P4Grammar
tableProperty
  : constENTRIES '=' '{' entriesList '}'/* immutable entries */

entriesList
: entry
| entryList entry

entry
: keysetExpression ':' actionRef optAnnotations ';'

~ End P4Grammar

In the current specification, we define entries as immutable (const)
-- they can only be read, not changed or removed through control plane
APIs. It follows that tables that define entries in the P4 source are
immutable, thus no additional entries may be inserted in tables that
define a set of immutable entries.  This design choice is important
for the P4 runtime since it does not have to keep track of different
types of entries in one table (mutable and immutable).  Future
versions of the specification may add mutable entries and shall
preserve compatibility with the current specification by declaring
additional ```entries``` properties without the ```const``` keyword.

The ```keysetExpression``` component of an entry is a tuple that must
provide a field for each key in the table keys (see
Sec. [#sec-table-props]). The table key type must match the type of
the element of the set. ```actionRef``` must be an action which
appears in the table actions list, with all its arguments bound.

Entries in a table are matched in priority order, with the priority
computed based on the program order of the entries -- entries occuring
first have higher priority.

Depending on the ```match_kind``` of the keys, key set expressions may define
one or multiple entries. The compiler will synthesize the correct number of
entries to be installed in the table. Target constraints may further restrict
the ability of synthesizing entries. For example, if the number of synthesized
entries exceeds the table size, the compiler implementation may choose to issue
a warning or an error, depending on target capabilities.

Consider the following example:

~ Begin P4Example
header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_exact_ternary {

  	key = {
            h.h.e : exact;
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

    const entries = {
            (0x01, 0x1111 &&& 0xF   ) : a_with_control_params(1);
            (0x02, 0x1181           ) : a_with_control_params(2);
            (0x03, 0x1111 &&& 0xF000) : a_with_control_params(3);
            (0x04, 0x1211 &&& 0x02F0) : a_with_control_params(4);
            (0x04, 0x1311 &&& 0x02F0) : a_with_control_params(5);
            (0x06, _                ) : a_with_control_params(6);
        }
    }

}
~ End P4Example

In this example we define a set of 6 entries that populate various
fields in the header and send the invoke one action ```a_with_control_params```
to send the packet to a particular output port. Once the program is
loaded, these entries are installed in the table in the order they are
enumerated in the program, with decreasing priority levels.

#### Additional table properties {#sec-additional-table-properties}

A ```table``` declaration indicates the interfaces expected from a ```table```:
keys and actions. However, the best way to implement a table is
actually dependent on the nature of the entries that will populate the
table at runtime (for example, tables could be dense or sparse, could
be implemented as hash-tables, associative memories, tries, etc.) Some
architectures may provide additional table properties whose semantics
lies outside the scope of this specification. For example, in
architectures where table resources are statically allocated,
programmers may be required to define a ```size``` table property,
which can be used by the compiler back-end to allocate storage
resources. However, an architecture-specific property may not change
the semantics of table lookups, which always produce either a ```hit```
and an action or a ```miss```---they can only change how those results
are interpreted on the state of the data plane. This restriction is
needed to ensure that it is possible to reason about the behavior of
tables during compilation.

As another example, an ```implementation``` property could be used to
pass additional information to the compiler back-end. The value of
this property could be an instance of an ```extern``` block chosen
from a suitable library of components. For example, the core
functionality of the P4~14~ table ```action_profile``` constructs
could be implemented on architectures that support this feature using
a construct such as the following:

~ Begin P4Example
extern ActionProfile {
   ActionProfile(bit<32> size); // how many distinct actions are expected
}
table t {
    key = { ...}
    size = 1024;
    implementation = ActionProfile(32);  // constructor invocation
}
~ End P4Example

(An action profile specifies the fact that, although the table is
expected to have a large number of entries, only a small number of
distinct entry values are expected. This can lead to an optimized
implementation of the table, using an indirection level to share
identical entries. The ```ActionProfile``` ```extern``` object in the
previous example is meant to convey this information.)

### Invoking a table (match-action unit) { #sec-invoke-mau }

A ```table``` is invoked by calling its ```apply``` method. Calling an
apply method on a table instance returns a value with a ```struct```
type with two fields. This structure is synthesized by the compiler
automatically. For each ```table T```, the compiler synthesizes an ```enum```
and a ```struct```, shown in pseudo-P4:

~ Begin P4Pseudo
enum action_list(T) {
   // one field for each action in the actions list of table T
}
struct apply_result(T) {
    bool hit;
    action_list(T) action_run;
}
~ End P4Pseudo

The evaluation of the ```apply``` method sets the ```hit``` field to ```true```
if a match is found in the lookup-table. This bit can be used to drive
the execution of the control-flow in the control block that invoked
the table:

~ Begin P4Example
if (ipv4_match.apply().hit) {
    // there was a hit
} else {
    // there was a miss
}
~ End P4Example

The ```action_run``` field indicates which kind of action was executed
(irrespective of whether it was a hit or a miss). It can be used in a
switch statement:

~ Begin P4Example
switch (dmac.apply().action_run) {
    Drop_action: { return; }
}
~ End P4Example

### Match-action unit execution semantics { #sec-mau-semantics }

The semantics of a table invocation statement:

~ Begin P4Example
m.apply();
~ End P4Example

is given by the following pseudo-code (see also Figure
[#fig-maudataflow]):

~ Begin P4Pseudo
apply_result(m) m.apply() {
    apply_result(m) result;

    var lookupKey = m.buildKey(m.key); // using key block
    action RA = m.table.lookup(lookupKey);
    if (RA == null) {      // miss in lookup table
       result.hit = false;
       RA = m.default_action;  // use default action
    }
    else {
       result.hit = true;
    }
    result.action_run = action_type(RA);
    evaluate_and_copy_in_RA_args(RA);
    execute(RA);
    copy_out_RA_args(RA);
    return result;
}
~ End P4Pseudo

## The Match-Action Pipeline Abstract Machine { #sec-mau-abstract-mach }

We can describe the computational model of a match-action pipeline,
embodied by a control block: the body of the control block is
executed, similarly to the execution of a traditional imperative
program:

- At runtime, statements within a block are executed in the order
  they appear in the control block.
- Execution of the ```return``` statement causes immediate termination
  of the execution of the current ```control``` block, and a return to
  the caller.
- Execution of the ```exit``` statement causes the immediate
  termination of the execution of the current ```control``` block and
  of all the enclosing caller ```control``` blocks.
- Applying a ```table``` causes the execution of the corresponding
  match-action unit, as described above.

## Invoking controls { #sec-invoke-controls }

P4 allows controls to invoke the services of other controls, similar
to subroutines. To invoke the services of another control, it must be
first instantiated; the services of an instance are invoked by calling
it using its ```apply``` method.

The following example shows a control invocation:

~ Begin P4Example
control Callee(inout IPv4 ipv4) { ...}
control Caller(inout Headers h) {
     Callee() instance;  // instance of callee
     apply {
          instance.apply(h.ipv4);  // invoke control
     }
}
~ End P4Example

# Parameterization { #sec-parametrization }

In order to support libraries of useful P4 components, both ```parser```s
and ```control``` blocks can be additionally parameterized through the
use of constructor parameters.

Consider again the parser declaration syntax:

~ Begin P4Grammar
parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      '{' parserLocalElements parserStates '}'
    ;

optConstructorParameters
    : /* empty */
    | '(' parameterList ')'
    ;
~ End P4Grammar

From this grammar fragment we infer that a ```parser``` declaration
can have two sets of parameters:

-	The runtime parser parameters
-	Optional parser constructor parameters
     (```optConstructorParameters```)

All constructor parameters must be directionless (i.e., they cannot be ```in```, ```out```,
or ```inout```). When instantiating a parser one has to supply
expressions that can be fully evaluated at compilation time for all ```optConstructorParameters```.

Consider the following example:

~ Begin P4Example
parser GenericParser(packet_in b,          // parser API
                     out Packet_header p)
                     (bool udpSupport) {   // constructor parameters
    EthernetParser() ethParser;
    state start {
        ethParser.apply(b, p.ethernet);
        transition select(p.ethernet.etherType) {
            16w0x0800: ipv4;
        }
    }
    state ipv4 {
        b.extract(p.ipv4);
        transition select(p.ipv4.protocol) {
           6: tcp;
           17: tryudp;
        }
    }
    state tryudp {
        transition select(udpSupport) {
            false: accept;
            true : udp;
        }
    }
    state udp {
         ...
    }
}
~ End P4Example

When instantiating the ```GenericParser``` one must supply a value for
the ```udpSupport``` parameter, as in the following example:

~ Begin P4Example
// TopParser is a GenericParser where udpSupport = false
GenericParser(false) TopParser;
~ End P4Example

## Optional constructor parentheses

For the sake of readability, type definitions with no constructor
arguments may omit the second set of parentheses.  That is, ```control
c(...)();``` and ```control c(...);``` are equivalent.

## Direct type invocation

Controls and parsers are often instantiated exactly once.  As a light
syntactic sugar, control and parser declarations with no constructor
parameters may be applied directly, as if they were an instance.  This
has the effect of creating and applying a local instance of that type.

~ Begin P4Example
control callee( ... ) { ... }

control caller( ... )( ... ) {
    apply {
        callee.apply( ... ); // callee is treated as an instance
    }
}
~ End P4Example

The definition of ```caller``` is equivalent to the following.

~ Begin P4Example
control caller( ... )( ... ) {
    @name("callee") callee() callee_inst; // local instance of callee
    apply {
        callee_inst.apply( ... );         // callee_inst is applied
    }
}
~ End P4Example

This feature is intended to ease the case where a type is instantiated
exactly once.  For completeness, the behavior of directly invoking the
same type more than once is defined as follows.

- Direct type invocation in different scopes will result in different
  local instances with different fully-qualified control names.
- In the same scope, direct type invocation will result in a different
  local instance per invocation---however, instances of the same type
  will share the same global name, via the ```@name``` annotation.  If
  the type contains controllable entities, then invoking it directly
  more than once in the same scope is illegal, because it will produce
  multiple controllable entities with the same fully-qualified control
  name.

See Section [#sec-name-annotations] for details of ```@name```
annotations.

# Packet construction (deparsing) { #sec-deparse }

The inverse of parsing is deparsing, or packet construction. P4 does
not provide a separate language for packet deparsing; deparsing is
done in a ```control``` block that has at least one parameter of type ```packet_out```.

For example, the following code sequence writes first an Ethernet
header and then an IPv4 header into a ```packet_out```:

~ Begin P4Example
control TopDeparser(inout Parsed_packet p, packet_out b) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip);
    }
}
~ End P4Example

Emitting a header appends the header to the ```packet_out``` only if
the header is valid. Emitting a header stack will emit all elements of
the stack in order of increasing indexes.

## Data insertion into packets { #sec-deparse-insert }

The ```packet_out``` datatype is defined in the P4 core library, and
reproduced below. It provides two methods for appending data to an
output packet; both methods are called ```emit```. The first version
only accepts headers, and the second one accepts arbitrary data.

~ Begin P4Example
extern packet_out {
    void emit<T>(in T hdr);
    void emit<T>(in bool condition, in T data);
}
~ End P4Example

The first version of ```emit``` just calls the second one with the
header validity bit as a condition.

We describe the meaning of these methods in pseudo-code as follows:

~ Begin P4Pseudo
packet_out {
    byte[] data;
    unsigned lengthInBits;
    void initializeForWriting() {
        this.data.clear();
        this.lengthInBits = 0;
    }
    // append entire header if it is valid
    // T must be a header type
    void emit<T>(T header) {
        this.emit(header.valid$, header);
    }

    // append the data to the packet if the condition is true
    void emit<T>(bool cond, T data) {
        if (!cond) return;
        this.data.append(data);
        this.lengthInBits += data.lengthInBits;
    }
}
~ End P4Pseudo

We describe the two-argument ```emit``` method. For a base type ```T```, ```emit```:

- does nothing if the condition is ```false```,
- otherwise it appends the ```data``` value to the tail of the ```packet_out```.

For derived type, ```emit``` recursively proceeds on fields:

- If the argument is a header, its validity bit is AND-ed with the
  condition bit to determine; if the result is ```false``` no action
  is taken
- If the argument is a header stack, the ```emit``` statement is
  applied to each component of the stack starting from the element
  with index 0.
- If the argument is a ```struct``` containing multiple fields, the ```emit```
  is recursively applied to each component of the struct in the order
  of their declaration in the struct.

Appending a bit-string or integer value to a ```packet_out``` writes
the value starting with the most-significant bit. This process is the
inverse of data extraction.

# Architecture description { #sec-arch-desc }

The architecture description must be provided by the target
manufacturer in the form of a library P4 source file that contains at
least one declaration for a ```package```; this ```package``` must be
instantiated by the user to construct a program for a target. For an
example see the Very Simple Switch declaration from Section
[#sec-vss-arch].

The architecture description file may pre-define data types,
constants, helper package implementations, and errors. It must also
declare the types of all the programmable blocks that will appear in
the final target: ```parser```s and ```control``` blocks. The
programmable blocks may optionally be grouped together in packages,
which can be nested.

Since some of the target components may manipulate user-defined types,
which are unknown at the target declaration time, these are described
using type parameters (type variables). This mechanism is similar to
the use of generic types or templates in languages such as C++ and
Java.

## Example architecture description { #sec-arch-desc-example }

The following example describes a switch by using two packages, each
containing a parser, a match-action pipeline, and a deparser:

~ Begin P4Example
parser Parser<IH>(packet_in b, out IH parsedHeaders);
// ingress match-action pipeline
control IPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         out OH outputHeaders,
                         out T toEgress,
                         out OutControl outCtrl);
// egress match-action pipeline
control EPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         in T fromIngress,
                         out OH outputHeaders,
                         out OutControl outCtrl);

control Deparser<OH>(in OH outputHeaders, packet_out b);
package Ingress<T, IH, OH>(Parser<IH> p,
                           IPipe<_, IH, OH> map,
                           Deparser<OH> d);
package Egress<T, IH, OH>(Parser<IH> p, Port
                          EPipe<_, IH, OH> map,
                          Deparser<OH> d);
package Switch<T>( // Top-level switch contains two packages
    // type types Ingress.IH and Egress.IH may be different
    Ingress<T, _, _> ingress,
    Egress<T, _, _> egress
);
~ End P4Example

~ Figure { #fig-switcharch; caption: "Switch architecture fragment implied by the previous set of declarations." }
![switcharch]
~
[switcharch]: figs/switcharch.png { width: 80%; page-align: here }

[]{tex-cmd: "\indent"}
Just from these declarations, even without reading a precise
description of the target, the programmer can infer some useful
information about the architecture of the described switch, as shown
in Figure [#fig-switcharch]:

- The switch contains two separate ```package```s ```Ingress``` and ```Egress```
- The ```Parser```, ```IPipe```, and ```Deparser``` in the ```Ingress``` package
  are chained in this order. The ```Ingress.IPipe``` block has an
  input of type ```Ingress.IH```, which is an output of the ```Ingress.Parser```.
- Similarly, the ```Parser```, ```EPipe```, and ```Deparser``` are
  chained in the ```Egress``` package.
- The ```Ingress.IPipe``` is connected to the ```Egress.EPipe```,
  because the first one outputs a value of type ```T```, which is an
  input to the second.
- Note that the ```Ingress``` type ```IH``` and the ```Egress``` type ```IH```
  are independent. If we had wanted to show that they are the same
  type, we would have instead declared ```IH``` and ```OH``` at the
  switch level: ```package Switch<IH, OH, T>```.

Note that this architecture models a target switch that contains two
separate channels between the ingress and egress pipeline:

- A channel that can pass data directly (through the ```T```-type
  argument -- on a software target with shared memory between ingress
  and egress this could be implemented by passing directly a pointer;
  on an architecture without shared memory presumably the compiler
  will need to synthesize automatically serialization code).
- Indirectly through a parser/deparser that serialize data to a packet
  and back.

## Target program instantiation { #sec-target-instantiation }

In order to build a program for the target, the compiled P4 program
has to instantiate a top-level ```package``` by passing values for all
its arguments creating a variable called ```main``` in the top-level
namespace. The types of the arguments have to match the types of the
parameters --- after a suitable substitution of the type
variables. The type substitution can be expressed directly, using type
specialization, or can be inferred by a compiler, using a unification
algorithm like Hindley-Milner.

For example, given the following type declarations:

~ Begin P4Example
parser Prs<T>(packet_in b, out T result);
control Pipe<T>(in T data);
package Switch<T>(Prs<T> p, Pipe<T> map);
~ End P4Example

and the following declarations:

~ Begin P4Example
parser P(packet_in b, out bit<32> index) { ... }
control Pipe1(in bit<32> data) { ... }
control Pipe2(in bit<8> data) { ... }
~ End P4Example

The following is a legal declaration for the top-level target:

~ Begin P4Example
Switch(P(), Pipe1()) main;
~ End P4Example

And the following is illegal:

~ Begin P4Example
Switch(P(), Pipe2()) main;
~ End P4Example

The latter declaration is incorrect because the parser ```P```
requires ```T``` to be ```bit<32>```, while ```Pipe2``` requires ```T```
to be ```bit<8>```.

The user can also explicitly specify values for the type variables
(otherwise the compiler has to infer values for these type variables):

~ Begin P4Example
Switch<bit<32>>(P(), Pipe1()) main;
~ End P4Example

## A Packet Filter Model { #sec-pkt-filter }

~ Figure { #fig-packetfilter; caption: "A packet filter target model. The parser computes a boolean value, which is used to decide whether the packet is dropped." }
![packetfilter]
~
[packetfilter]: figs/packetfilter.png { width: 5cm; page-align: here }

[]{tex-cmd: "\indent"}
To illustrate the versatility of P4 architecture description language,
we give an example of another architecture, which models a packet
filter that makes a drop/no drop decision based only on the
computation in a P4 parser, as shown in Figure [#fig-packetfilter].

This model could be used to program packet filters running in the
Linux kernel. For example, we could replace the TCP dump language with
the much more powerful P4 language; P4 can support seamlessly new
protocols, while providing complete "type safety" during packet
processing. For such a target the P4 compiler could generate an eBPF
(Extended Berkeley Packet Filter) program, which is injected by the
TCP dump utility into the Linux kernel, and executed by the EBPF
kernel JIT compiler/runtime.

In this case the target is the Linux kernel, and the architecture
model is a packet filter.

The declaration for this architecture is very simple:
~ Begin P4Example
parser _parser<H>(packet_in packet, out H headers);
control _filter<H>(inout H headers, out bool accept);

package Filter<H>(_parser<H> p, _filter<H> f);
~ End P4Example

# P4 abstract machine: Evaluation { #sec-p4-abstract-mach }

The evaluation of a P4 program is done in two stages:

- **static evaluation**: at compilation time the P4 program is
  analyzed and all stateful blocks are instantiated.
- **dynamic evaluation**: at runtime each P4 functional block is
  executed atomically, in isolation, when it receives control from the
  architecture

## Compile-time known values { #sec-ct-constants }
The following are compile-time known values:

- Integer literals, boolean literals, and string literals.
- Identifiers declared in an ```error```, ```enum```, or ```match_kind```
  declaration.
- The ```default``` identifier.
- The `size` field of a value with type header stack.
- The ```_``` identifier when used as a ```select``` expression label
- Identifiers that represent declared types, actions, tables, parsers,
  controls, or packages.
- List expression where all components are compile-time known values.
- Instances constructed by instance declarations (Section
  [#sec-instantiations]) and constructor invocations.
- The following expressions (```+```, ```-```, ```*```, ```/ ```, ```%```, ```cast```, ```!```, ```&```, ```|```, ```&&```, ```||```, ```<< ```, ```>> ```, ```~``` ```, ```\ ```>```, ```<```, ```==```, ```!=```, ```<=```, ```>=```, ```++```, ```[:]```)
  when their operands are all compile-time known values.
- Identifiers declared as constants using the ```const``` keyword.

## Compile-time Evaluation { #sec-ct-eval }

Evaluation of a program proceeds in order of declarations, starting in
the top-level namespace:

- All declarations (e.g., ```parsers```, ```controls```, types,
  constants) evaluate to themselves.
- Each ```table``` evaluates to a table instance.
- Constructor invocations evaluate to stateful objects of the
  corresponding type. For this purpose, all constructor arguments are
  evaluated recursively and bound to the constructor
  parameters. Constructor arguments must be compile-time known
  values. The order of evaluation of the constructor arguments should
  be unimportant --- all evaluation orders should produce the same
  results.
- Instantiations evaluate to named stateful objects.
- The instantiation of a ```parser``` or ```control``` block
  recursively evaluates all stateful instantiations declared in the
  block.
- The result of the program's evaluation is the value of the top-level ```main```
  variable.

Note that all stateful values are instantiated at compilation time.

As an example, consider the following program fragment:

~ Begin P4Example
// architecture declaration
parser p(...);
control c(...);
control d(...);

package Switch(p prs, c ctrl, d dep);

extern Checksum16 { ...}

// user code
Checksum16() ck16; // checksum unit instance

parser TopParser(...)(Checksum16 unit) { ...}
control Pipe(...) { ...}
control TopDeparser(...)(Checksum16 unit) { ...}

Switch(TopParser(ck16),
       Pipe(),
       TopDeparser(ck16)) main;
~ End P4Example

The evaluation of this program proceeds as follows:

1.	The declarations of ```p```, ```c```, ```d```, ```Switch```, and ```Checksum16``` all
      evaluate as themselves.
2.	The ```Checksum16() ck16``` instantiation is evaluated and it
      produces an object named ```ck16``` with type ```Checksum16```.
3.	The declarations for ```TopParser```, ```Pipe```, and ```TopDeparser```
    evaluate as themselves.
4.	The ```main``` variable instantiation is evaluated:
  1.	The arguments to the constructor are evaluated recursively
  2.	```TopParser(ck16)``` is a constructor invocation
     1.	Its argument is evaluated recursively; it evaluates to the ```ck16```
        object
  3.	The constructor itself is evaluated, leading to the
        instantiation of an object of type ```TopParser```
  4.	Similarly, ```Pipe()``` and ```TopDeparser(ck16)``` are
        evaluated as constructor calls.
  5.	All the arguments of the ```Switch``` package constructor have
        been evaluated (they are an instance of ```TopParser```, an
        instance of ```Pipe```, and an instance of ```TopDeparser```).
        Their signatures are matched with the ```Switch``` declaration.
  6.	Finally, the ```Switch``` constructor can be evaluated. The
        result is an instance of the ```Switch``` package (that
        contains a ```TopParser``` named ```prs``` --- the first
        parameter of the ```Switch```, a ```Pipe``` named ```ctrl```
        and a ```TopDeparser``` named ```dep```).
5.	The result of the program evaluation is the value of the ```main```
    variable, which is the above instance of the ```Switch package```.

Figure [#fig-compileeval] shows the result of the evaluation in a
graphical form. The result is always a graph of instances. There is
only one instance of ```Checksum16```, called ```ck16```, shared
between the ```TopParser``` and ```TopDeparser```. Whether this is
possible is architecture-dependent. Specific target compilers may
require distinct checksum units to be used in distinct blocks.

~ Figure { #fig-compileeval; caption: "Evaluation result." }
![compileeval]
~
[compileeval]: figs/compileeval.png { width: 5cm; page-align: here }

## Control plane names { #sec-cp-names }

Every controllable entity exposed in a P4 program must be assigned a
unique, fully-qualified name, which the control plane may use to
interact with that entity.  The following entities are controllable.

 - tables
 - keys
 - actions
 - extern instances

A fully qualified name consists of the local name of a controllable
entity prepended with the fully qualified name of its enclosing
namespace.  Hence, the following program constructs, which enclose
controllable entites, must themselves have unique, fully-qualified
names.

 - control instances
 - parser instances

The evaluation process may create multiple instances from one type,
each of which must have a unique, fully-qualified name.

### Computing control names

The fully-qualified name of a construct is derived by concatenating
the fully-qualified name of its enclosing construct with its local
name.  Constructs with no enclosing namespace, i.e. those defined at
the global scope, have the same local and fully-qualified names.  The
local names of controllable entities and enclosing constructs are
derived from the syntax of a P4 program as follows.

#### Tables { #sec-cp-tables }

For each ```table``` construct, its syntactic name becomes the local
name of the table.  For example:

~ Begin P4Example
control c(...)() {
    table t { ... }
}
~ End P4Example

This table's local name is ```t```.

#### Keys { #sec-cp-keys }

Syntactically, table keys are expressions.  For simple expressions,
the local key name can be generated from the expression itself.  In
the following example, the table ```t``` has keys with names ```data.f1```
and ```hdrs[3].f2```.

~ Begin P4Example
table t {
    keys = {
        data.f1 : exact;
        hdrs[3].f2 : exact;
    }
    actions = { ... }
}
~ End P4Example

The following kinds of expressions have local names derived from their
syntactic names:

| Kind | Example | Name |
| ---- | ------- | ---- |
| The ```isValid()``` method. | ```h.isValid()``` | ```"h.isValid()"``` |
| Array accesses. | ```header_stack[1]``` | ```"header_stack[1]"``` |
| Constants. | ```1``` | ```"1"``` |
| Field projections. | ```data.f1``` | ```"data.f1"``` |
| Slices. | ```f1[3:0]``` | ```"f1[3:0]"``` |

All other kinds of expressions **must** be annotated with a ```@name```
annotation (Section [#sec-control-plane-api-annotations]), as in the
following example.

~ Begin P4Example
table t {
    keys = {
        data.f1 + 1 : exact @name("f1_inc");
    }
    actions = { ... }
}
~ End P4Example

Here, the ```@name("f1_mask")``` annotation assigns the local name ```"f1_mask"```
to this key.

#### Actions { #sec-cp-actions }

For each ```action``` construct, its syntactic name is the local name
of the action.  For example:

~ Begin P4Example
control c(...)() {
    action a(...) { ... }
}
~ End P4Example

This action's local name is ```a```.

#### Instances { #sec-cp-instances }

The local names of ```extern```, ```parser```, and ```control```
instances are derived based on how the instance is used.  If the
instance is bound to a name, that name becomes its local control plane
name.  In the following example, the local name of the instance is ```c_inst```.

~ Begin P4Example
control c(...)() { ... }
c() c_inst;
~ End P4Example

Otherwise, if the instance is created as an actual argument, then its
local name is the name of the formal parameter to which it will be
bound.  In the following example, the local name of the extern
instance is ```e_in```.

~ Begin P4Example
extern e( ... ) { ... }
control c ( ... )(e e_in) { ... }
c(e()) c_inst;
~ End P4Example

If the construct being instantiated is passed as an argument to a
package, the instance name is derived from the user-supplied type
definition when possible.  In the following example, the local name of
the instance of ```MyC``` is ```c```, and the local name of the extern
is ```e2```, not ```e1```.

~ Begin P4Example
extern ExternX { ... }
control ArchC(ExternX e1);
package Arch(ArchC c);

control MyC(ExternX e2)() { ... }
Arch(MyC()) main;
~ End P4Example

Note that in this example, the architecture will supply an instance of
the extern when it applies the instance of ```MyC``` passed to the ```Arch```
package.  The fully-qualified name of that instance is ```main.c.e2```.

A programmer can always assign a control plane name to an instance by
binding it to a name in the program, rather than relying on the
parameter name supplied by the type definition or architecture.

~ Begin P4Example
MyC() d;
Arch(d) main;
~ End P4Example

In the example above, the name of the ```MyC``` instance is ```d```.
Next, consider a larger example that demonstrates name generation when
there are multiple instances.

~ Begin P4Example
control Callee() {
    table t { ... }
    apply { t.apply(); }
}
control Caller() {
    Callee() c1;
    Callee() c2;
    apply {
       c1.apply();
       c2.apply();
    }
}
control Simple();
package Top(simple s);
Top(Caller()) main;
~ End P4Example

The compile-time evaluation of this program produces the structure in
Figure [#fig-evalmultiple]. Notice that there are two instances of the ```table t```.
These instances must both be exposed to the control plane. To name an
object in this hierarchy, one uses a path composed of the names of
containing instances.  In this case, the two tables have names ```s.c1.t```
and ```s.c2.t```, where ```s``` is the name of the argument to the
package instantiation, which is derived from the name of its
corresponding formal parameter.

~ Figure { #fig-evalmultiple; caption: "Evaluating a program that has several instantiations of the same component." }
![evalmultiple]
~
[evalmultiple]: figs/evalmultiple.png { width: 5cm; page-align: here }


### Annotations controlling naming { #sec-name-annotations }

Control plane-related annotations (Section
[#sec-control-plane-api-annotations]) can alter the names exposed to
the control plane in the following ways.

- The ```@hidden``` annotation hides a controllable entity from the
  control plane.  This is the only case in which a controllable entity
  is not required to have a unique, fully-qualified name.

- The ```@name``` annotation may be used to change the local name of a
  controllable entity.

- The ```@globalname``` annotation my be used to change the global
  name of a controllable entity.

Programs that yield the same fully-qualified name for two different
controllable entities are invalid.  Care must be taken with ```@globalname```
in particular: If a type contains a ```@globalname``` annotation and
is instantiated twice, the two instances will have the same
fully-qualified name.

### Recommendations

The control plane may refer to a controllable entity by a postfix of
its fully qualified name when it is unambiguous in the context in
which it is used.  Consider the following example.

~ Begin P4Example
control c( ... )() {
    action a ( ... ) { ... }
    table t {
        keys = { ... }
        actions = { a; } }
}
c() c_inst;
~ End P4Example

Control plane software may refer to action ```c_inst.a``` as ```a```
when inserting rules into table ```c_inst.t```, because it is clear
from the definition of the table which action ```a``` refers to.

Not all unambiguous postfix shortcuts are recommended.  Consider the
first example in Section [#sec-cp-names].  One might be tempted to
refer to ```s.c1``` simply as ```c1```, as no other instance named ```c1```
appears in the program.  However, this leads to a brittle
program: Future modifications can never introduce an instance named ```c1```
or include libraries of P4 code that contain instances with
that name.

## Dynamic evaluation { #sec-dynamic-eval }

The dynamic evaluation of a P4 program is orchestrated by the target
model. Each target model needs to specify the order and the conditions
under which the various P4 component programs are dynamically
executed. For example, in the Simple Switch example from Section
[#sec-vss-arch] the execution flow goes ```Parser->Pipe->Deparser```.

Once a P4 execution block is invoked its execution proceeds until
termination according to the semantics defined in this document (the
various abstract machines).

### Concurrency model { #sec-concurrency }

A typical packet processing system needs to execute multiple
simultaneous logical threads: at the very least there is a thread
executing the control plane, which can modify the contents of the
tables. Architecture specifications should describe in detail the
interactions between the control-plane and the data-plane. The data
plane can exchange information with the control plane through ```extern```
function and method calls. Moreover, high throughput packet processing
systems may be processing multiple packets simultaneously, e.g., in a
pipelined fashion, or concurrently parsing a first packet while
performing match-action operations on a second packet. This section
specifies the semantics of P4 programs with respect to such concurrent
executions.

Each top-level ```parser``` or ```control``` block is executed as a
separate thread when invoked by the architecture. All the parameters
of the block and all local variables are thread-local: i.e., each
thread has a private copy of these resources. This applies to the ```packet_in```
and ```packet_out``` parameters of parsers and deparsers.

As long as a P4 block uses only thread-local storage (e.g., metadata,
packet headers, local variables), its behavior in the presence of
concurrency is identical with the behavior in isolation, since any
interleaving of statements from different threads must produce the
same output.

In contrast, ```extern``` blocks instantiated by a P4 program are
global, shared across all threads. If ```extern``` blocks mediate
access to state (e.g., counters, registers) -- i.e., the methods of
the ```extern``` block read and write state, these stateful operations
are subject to data races. P4 mandates the following behaviors:

- Execution of an action is atomic, i.e., the other threads can see
  the state as it is either before the start of the action or after
  the completion of the action.
- Execution of a method call on an extern instance is atomic.

To allow users to express atomic execution of larger code blocks, P4
provides an ```@atomic``` annotation, which can be applied to block
statements, parser states, control blocks, or whole parsers.

Consider the following example:

~ Begin P4Example
extern Register { ... }
control Ingress() {
  Register() r;
  table flowlet { /* read state of r in an action */ }
  table new_flowlet { /* write state of r in an action */ }
  apply {
    @atomic {
       flowlet.apply();
       if (ingress_metadata.flow_ipg > FLOWLET_INACTIVE_TIMEOUT)
          new_flowlet.apply();
}}}
~ End P4Example

This program accesses an extern object ```r``` of type ```Register```
in actions invoked from tables ```flowlet``` (reading) and ```new_flowlet```
(writing). Without the ```@atomic``` annotation these two operations
would not execute atomically: a second packet may read the state of ```r```
before the first packet had a chance to update it.

A compiler backend must reject a program containing ```@atomic```
blocks if it cannot implement the atomic execution of the instruction
sequence. In such cases, the compiler should provide reasonable
diagnostics.

# Annotations { #sec-annotations }

Annotations are similar to C# attributes and Java annotations. They
are a simple mechanism for extending the P4 language to some limited
degree without changing the grammar. To some degree they subsume the C ```#pragmas```.
Annotations can be added to types, fields, variables, etc. using the ```@```
syntax (as shown explicitly in the P4 grammar):

~ Begin P4Grammar
optAnnotations
    : /* empty */
    | annotations
    ;

annotations
    : annotation
    | annotations annotation
    ;

annotation
    : '@' name
    | '@' name '(' expressionList ')'
    ;
~ End P4Grammar

## Predefined annotations

Annotation names that start with lowercase letters are reserved for
the standard library and architecture.  This document pre-defines a
set of "standard" annotations.  We expect that this list will grow.
We encourage custom architectures to define annotations starting with
a manufacturer prefix: e.g., company X would use annotations named
like ```@X_annotation```

### Annotations on the table action list

The following two annotations can be used to give additional
information to the compiler and control-plane about actions in a
table. They have no arguments.

- ```@tableonly```: actions with this annotation can only appear
  within the table, and never as default action.
- ```@defaultonly```: actions with this annotation can only appear in
  the default action, and never in the table.

~ Begin P4Example
table t {
    actions = {
       a,              // can appear anywhere
       @tableonly b,   // can only appear in the table
       @defaultonly c, // can only appear in the default action
    }
    ...
}
~ End P4Example

### Control-plane API annotations { #sec-control-plane-api-annotations }

The ```@name``` annotation directs the compiler to use a different
local name when generating the external APIs used to manipulate a
language element from the control plane. It must have a string literal
argument, which shall not contain the "```.```" character.  In the
following example, the fully-qualified name of the table is ```c_inst.t1```.

~ Begin P4Example
control c( ... )() {
    @name("t1") table t { ... }
    apply { ... }
}
c() c_inst;
~ End P4Example

The ```@globalname``` annotation acts like the ```@name``` annotation,
except it overrides the fully-qualified name (not just the local name)
for the annotated element, and its argument may contain the "```.```"
character.  In the following example, the fully-qualified name of the
table is ```foo.bar```.

~ Begin P4Example
control c( ... )() {
    @globalname("foo.bar") table t { ... }
    apply { ... }
}
c() c_inst;
~ End P4Example

The ```@hidden``` annotation hides a controllable entity, eg. a table,
key, action, or extern, from the control plane.  This effectively
removes its fully-qualified name (Section [#sec-cp-names]).  It does
not take any arguments.

#### Restrictions

Each element may be annotated with at most one ```@name```, ```@globalname```,
or ```@hidden``` annotation, and each control plane name must refer to
at most one controllable entity.  This is of special concern when
using the ```@globalname``` annotation: If a type containing a ```@globalname```
annotation is instantiated more than once, it will result in the same
global name referring to two controllable entities.

~ Begin P4Example
control c( ... )() {
    @globalname("foo.bar") table t { ... }
    apply { ... }
}
c() c1;
c() c2;
~ End P4Example

Without the ```@globalname``` annotation, this program would produce
two controllable entities with fully-qualified names ```c1.t``` and ```c2.t```.
However, the ```@globalname("foo.bar")``` annotation renames table ```t```
in both instances to ```foo.bar```, resulting in one name that refers
to two controllable entities, which is illegal.

### Concurrency control annotations

The ```@atomic``` annotation, described in Section [#sec-concurrency]
can be used to enforce the atomic execution of a code block.

## Target-specific annotations

Each P4 compiler implementation can define additional annotations
specific to the target of the compiler. The syntax of the annotations
should conform to the above description. The semantics of such
annotations is target-specific. They could be used in a similar way to
pragmas in the C language.

The P4 compiler should provide:

- Errors when annotations are used incorrectly (e.g., an annotation
  expecting a parameter but used without arguments, or with arguments
  of the wrong type
- Warnings for unknown annotations.

# Appendix: P4 reserved keywords { #sec-p4-keywords; @h1:"A" }

The following table shows all P4 reserved keywords. Some identifiers
are treated as keywords only in specific contexts (e.g., the keyword ```actions```).

|:---{width:25%}---|:---{width:25%}---|:---{width:25%}---|:---{width:25%}---|
| ```action```   |  ```apply ``` | ```bit```        | ```bool``` |
| ```const```    |  ```control``` | ```default``` | ```else``` |
| ```enum```   | ```error```     |   ```extern```  |  ```exit```  |
| ```false```   |  ```header```   |  ```if```         |  ```in```   |
| ```inout``` | ```int```         | ```match_kind``` | ```package``` |
| ```parser``` | ```out```         | ```return```  | ```select``` |
| ```state``` | ```struct```   |  ```switch``` | ```table```    |
| ```transition``` |  ```true``` |  ```tuple``` | ```typedef``` |
| ```varbit```  | ```verify``` | ```void```       |   |
|------|------|------|------|

# Appendix: P4 core library { #sec-p4-core-lib }

The P4 core library contains declarations that are useful to most
programs.

For example, the core library includes the declarations of the
predefined ```packet_in```\ and ```packet_out``` extern objects, used
in parsers and deparsers to access packet data.

~ Begin P4Example
/// Standard error codes.  New error codes can be declared by users.
error {
    NoError,           /// No error.
    PacketTooShort,    /// Not enough bits in packet for 'extract'.
    NoMatch,           /// 'select' expression has no matches.
    StackOutOfBounds,  /// Reference to invalid element of a header stack.
    HeaderTooShort,    /// Extracting too many bits into a varbit field.
    ParserTimeout      /// Parser execution time limit exceeded.
}
extern packet_in {
    /// Read a header from the packet into a fixed-sized header @hdr and advance the cursor.
    /// May trigger error PacketTooShort or StackOutOfBounds.
    /// @T must be a fixed-size header type
    void extract<T>(out T hdr);
    /// Read bits from the packet into a variable-sized header @variableSizeHeader
    /// and advance the cursor.
    /// @T must be a header containing exactly 1 varbit field.
    /// May trigger errors PacketTooShort, StackOutOfBounds, or HeaderTooShort.
    void extract<T>(out T variableSizeHeader,
                    in bit<32> variableFieldSizeInBits);
    /// Read bits from the packet without advancing the cursor.
    /// @returns: the bits read from the packet.
    /// T may be an arbitrary fixed-size type.
    T lookahead<T>();
    /// Advance the packet cursor by the specified number of bits.
    void advance(in bit<32> sizeInBits);
    /// @return packet length in bytes.  This method may be unavailable on
    /// some target architectures.
    bit<32> length();
}
extern packet_out {
    /// Write @hdr into the output packet, advancing cursor.
    /// @T can be a header type, a header stack, a header_union, or a struct
    /// containing fields with such types.
    void emit<T>(in T hdr);
    /// If @condition is true write the specified @data into the output packet,
    /// advancing cursor.  @T can be a header type, a header stack, a header_union,
    /// or a struct containing fields with such types.  If @condition is false,
    /// do nothing.
    void emit<T>(in bool condition, in T data);
}
action NoAction() {}
/// Standard match kinds for table key fields.
/// Some architectures may not support all these match kinds.
/// Architectures can declare additional match kinds.
match_kind {
    /// Match bits exactly.
    exact,
    /// Ternary match, using a mask.
    ternary,
    /// Longest-prefix match.
    lpm
}
~ End P4Example

# Appendix: Checksums { #sec-checksums }

There are no built-in constructs in P4~16~ for manipulating packet
checksums. We expect that all checksum operations can be expressed as ```extern```
library objects that are provided in target-specific libraries. The
standard architecture library should provide such checksum units.

For example, one could provide an incremental checksum unit ```Checksum16```
(also described in the VSS example in Section [#sec-vss-extern]) for
computing 16-bit one's complement using an ```extern``` object with a
signature such as:

~ Begin P4Example
extern Checksum16 {
    Checksum16();              // constructor
    void clear();              // prepare unit for computation
    void update<T>(in T data); // add data to checksum
    void remove<T>(in T data); // remove data from existing checksum
    bit<16> get(); // get the checksum for the data added since last clear
}
~ End P4Example

IP checksum verification could be done in a parser as:

~ Begin P4Example
ck16.clear();           // prepare checksum unit
ck16.update(header.ipv4); // write header
verify(ck16.get() == 16w0, error.IPv4ChecksumError); // check for 0 checksum

~ End P4Example

IP checksum generation could be done as:

~ Begin P4Example
header.ipv4.hdrChecksum = 16w0;
ck16.clear();
ck16.update(header.ipv4);
header.ipv4.hdrChecksum = ck16.get();
~ End P4Example

Moreover, some switch architectures do not perform checksum
verification, but only update checksums incrementally to reflect
packet modifications. This could be achieved as well, as the following
P4 program fragments illustrates:

~ Begin P4Example
ck16.clear();
ck16.update(header.ipv4.hdrChecksum);  // original checksum
ck16.remove( { header.ipv4.ttl, header.ipv4.proto } );
header.ipv4.ttl = header.ipv4.ttl - 1;
ck16.update( { header.ipv4.ttl, header.ipv4.proto } );
header.ipv4.hdrChecksum = ck16.get();
~ End P4Example

# Appendix: Open Issues

There are a number of open issues that are currently under discussion
in the P4 design working group. A brief summary of these issues is
highlighted in this section. We seek input on these issues from the
community, and encourage experimenting with different implementations
in the compiler before converging on the specification.

## Portable Switch Architecture

Portability and composability are critical to P4's long-term success:
- Composability: implement different features, such as In-band Network
  Telemetry (INT), Network Virtualization, and Load Balancing in separate P4
  programs written for the PSA, should easily interoperate when invoked from a
  toplevel program.
- Portability: a P4 implementation of a certain function, such as INT, against
  PSA should work consistently across architectures that support the PSA.
To that end, a specification for an architecture definition that enables
programmers to write composable P4 programs, called the _Portable Switch
Architecture_, is being developed by the Architecture Working Group.

## Generalized switch statement behavior

P4~16~ includes both ```switch``` statements [#sec-switch-stmt] and ```select```
expressions [#sec-select]. There are real differences in the current
version of the language -- expression vs. statement, and the latter
must evaluate to a state value.

We propose generalizing ```switch``` statements to match the design
used in most programming language: a multi-way conditional that
executes the first branch that matches from a list of cases.

~ Begin P4Example
switch(e1,...,en) {
  pat_1 : stmt1;
  ...
  pat_m : stmtm;
}
~ End P4Example

Here, the value being scrutinized is given by a tuple ```(e1,...,en)```,
and the patterns are given by expressions that denote sets of
values. The value matches a branch if it is an element of the set
denoted by the pattern. Unlike C and C++, there is no break statement
so control "falls through" to the next case only when there is no
statement associated with the case label.

This design is intended to capture the standard semantics of ```switch```
statements as well as a common idiom in P4 parsers where they are used
to control transitions to different parser states depending on the
values of one or more previously-parsed values. Using ```switch```
statements, we can also generalize the design for parsers, eliminating
select and lifting most restrictions on which kinds of statements may
appear in a state. In particular, we allow conditional statements and ```select```
statements, which may be nested arbitrarily. This language can be
translated into more restricted versions, where the body of each state
comprised a sequence of variable declarations, assignments, and method
invocations followed by a single```transition``` statement by
introducing new states.

We also generalize the design for processing of table hit/miss and
actions in control blocks, by generating implicit types for actions
and results.

The counter-argument to this proposal is that the semantics of ```select```
in the parser is sufficiently distinct from the ```switch```
statement, and moreover these are constructs that network programmers
are already faminliar with, and they are typically mapped very
efficiently onto a variety of targets.

## Undefined behaviors

The presence of undefined behavior has caused numerous problems in
languages like C and HTML, including bugs and serious security
vulnerabilities. There are a few places where evaluating a P4 program
can result in undefined behaviors: out parameters, uninitialized
variables, accessing header fields of invalid headers, and accessing
header stacks with an out of bounds index. We think we should make
every attempt to avoid undefined behaviors in P4~16~, and therefore we
propose to strengthen the wording in the specification, such that by
default, we rule out programs that exhibit the behaviors mentioned
above. Given the concern for performance, we propose to define
compiler flags and/or pragmas that can override the safe
behavior. However, our expectation is that programmers should be
guided toward writing safe programs, and encouraged to think harder
when excepting from the safe behavior.

## Structured Iteration {#sec-structured-iteration}

Introducing a ```foreach``` style iterator for operating over header
stacks will alleviate the need of using C preprocessor directives to
specify the size of header stacks.

For example:
~ Begin P4Example
foreach hdr in hdrs {
  ... operations over HDR ...
}
~ End P4Example

Since the stacks are always known statically (at compile-time), the
compiler could transform the ```foreach``` statement into the
replicated code with explicit index references at compile-time. This
has the advantage of allowing the code to be written without regard to
a parameterized header stack length.

Since the compiler can statically determine the number of operations
that would result from the ```foreach``` it can also reject a program
if the result requires more action resources than are available, or
can split the action code up to fit available resources as needed.

# Appendix: P4 grammar  { #sec-grammar }

This is the grammar of P4~16~ written using the YACC/bison
language. Absent from this grammar is the precedence of various
operations.

The grammar is actually ambiguous, so the lexer and the parser must
collaborate for parsing the language. In particular, the lexer must be
able to distinguish two kinds of identifiers:

- Type names previously introduced (```TYPE``` tokens)
- Regular identifiers (```IDENTIFIER``` token)

The parser has to use a symbol table to indicate to the lexer how to
parse subsequent appearances of identifiers. For example, given the
following program fragment:

~ Begin P4Example
typedef bit<4> t;
struct s { ...}
t x;
parser p(bit<8> b) { ... }
~ End P4Example
The lexer has to return the following terminal kinds:
~ Begin P4Example
t - TYPE
s - TYPE
x - IDENTIFIER
p - TYPE
b - IDENTIFIER
~ End P4Example

This grammar has been heavily influenced by limitations of the Bison
parser generator tool.

Several other constant terminals appear in these rules:
~ Begin P4Example
- SHL is <<
- LE is <=
- GE is >=
- NE is !=
- EQ is ==
- PP is ++
- AND is &&
- OR is ||
- MASK is &&&
- RANGE is ..
- DONTCARE is _
~ End P4Example

The ```STRING_LITERAL``` token corresponds to a string literal
enclosed within double quotes, as described in Section
[#sec-string-literals].

All other terminals are uppercase spellings of the corresponding
keywords. For example, ```RETURN``` is the terminal returned by the
lexer when parsing the keyword return.

[INCLUDE="grammar.mdk"]
